"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projector/page",{

/***/ "(app-pages-browser)/./components/SongTree.tsx":
/*!*********************************!*\
  !*** ./components/SongTree.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SongTree: function() { return /* binding */ SongTree; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * SongTree Component\n *\n * Core visualization showing the song construction as a tree of options.\n * Displays dual paths: faction path (solid) and popular path (ghost/dashed).\n *\n * Features:\n * - Bottom-to-top row progression (row 0 at bottom)\n * - Grid layout during 'running' phase\n * - River delta layout during 'finale' phase (tight root, organically spreading tributaries)\n * - Smooth Catmull-Rom curved paths\n * - Animated individual audience paths during finale\n */ /* __next_internal_client_entry_do_not_use__ SongTree auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// ─── Constants ──────────────────────────────────────────────────────────────\nconst SVG_WIDTH = 800;\nconst SVG_HEIGHT = 700;\nconst OPTIONS_PER_ROW = 4;\nconst FACTION_COLORS = [\n    \"#e05c5c\",\n    \"#5cb8e0\",\n    \"#5ce08a\",\n    \"#e0c55c\"\n];\nconst DOT_RADIUS = 8;\nconst WINNER_RADIUS = 11;\n// Grid layout spacing\nconst GRID_COL_SPACING = 70;\nconst GRID_ROW_SPACING = 56;\n// Transition duration\nconst TRANSITION_DURATION_MS = 1500;\n// ─── Layout Functions ───────────────────────────────────────────────────────\n/**\n * Grid position - linear layout used during 'running' phase\n * Bottom-to-top: row 0 at bottom, higher rows at top\n */ function gridPosition(row, option, config) {\n    const { width, height } = config;\n    const x = width / 2 - GRID_COL_SPACING * 1.5 + option * GRID_COL_SPACING;\n    const y = height - 70 - row * GRID_ROW_SPACING;\n    return {\n        x,\n        y\n    };\n}\n/**\n * Delta position - river delta / tributary layout used during 'finale' phase\n * Single source at bottom, paths branch outward with organic spread.\n * Jitter increases with row depth for natural asymmetry.\n */ function deltaPosition(row, option, config, jitter) {\n    const { width, height } = config;\n    // Bottom-to-top Y positioning with increasing spacing toward the top\n    const y0 = height - 60;\n    const yTop = 60;\n    const totalH = y0 - yTop;\n    // Use a slight power curve so upper rows get more room to spread\n    const t = row / (config.rows - 1); // 0 at bottom, 1 at top\n    let y = y0 - t * totalH;\n    // Spread increases as a power curve — tight at the root, wide at the tips\n    const spread = 20 + Math.pow(row, 1.8) * 14;\n    // 4 options evenly distributed across the spread\n    const offsets = [\n        -1.5,\n        -0.5,\n        0.5,\n        1.5\n    ];\n    let x = width / 2 + offsets[option] * spread;\n    // Apply stable jitter — increases with row for organic feel\n    const key = \"\".concat(row, \"-\").concat(option);\n    if (jitter[key]) {\n        x += jitter[key].dx;\n        y += jitter[key].dy;\n    }\n    return {\n        x,\n        y\n    };\n}\n/**\n * Interpolate between grid and tree positions\n */ function interpolatedPosition(row, option, config, progress, jitter) {\n    const gridPos = gridPosition(row, option, config);\n    const deltaPos = deltaPosition(row, option, config, jitter);\n    return {\n        x: gridPos.x + (deltaPos.x - gridPos.x) * progress,\n        y: gridPos.y + (deltaPos.y - gridPos.y) * progress\n    };\n}\n/**\n * Generate stable jitter for delta layout.\n * Jitter magnitude increases with row index — tight at root, loose at tips.\n * Row 0 gets no jitter (common source), higher rows spread organically.\n */ function generateDeltaJitter(seed, numRows) {\n    let s = seed;\n    const rand = ()=>{\n        s = (s * 16807 + 0) % 2147483647;\n        return (s - 1) / 2147483646;\n    };\n    const jitter = {};\n    for(let row = 0; row < numRows; row++){\n        for(let opt = 0; opt < OPTIONS_PER_ROW; opt++){\n            // Scale jitter: none at row 0, increasing toward top rows\n            const magnitude = row <= 1 ? 0 : Math.pow(row - 1, 1.2) * 4;\n            jitter[\"\".concat(row, \"-\").concat(opt)] = {\n                dx: (rand() - 0.5) * magnitude,\n                dy: (rand() - 0.5) * magnitude * 0.6\n            };\n        }\n    }\n    return jitter;\n}\n// ─── Curve Generation ───────────────────────────────────────────────────────\n/**\n * Calculate distance between two points\n */ function distance(p1, p2) {\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n}\n/**\n * Generate a Catmull-Rom spline path string\n * Alpha 0.5 = centripetal (avoids cusps and self-intersections)\n */ function catmullRomPath(points) {\n    let alpha = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n    if (points.length === 0) return \"\";\n    if (points.length === 1) return \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    if (points.length === 2) {\n        return \"M \".concat(points[0].x, \",\").concat(points[0].y, \" L \").concat(points[1].x, \",\").concat(points[1].y);\n    }\n    // Duplicate first and last points for end tangents\n    const extended = [\n        points[0],\n        ...points,\n        points[points.length - 1]\n    ];\n    let path = \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    for(let i = 1; i < extended.length - 2; i++){\n        const p0 = extended[i - 1];\n        const p1 = extended[i];\n        const p2 = extended[i + 1];\n        const p3 = extended[i + 2];\n        const d1 = distance(p0, p1);\n        const d2 = distance(p1, p2);\n        const d3 = distance(p2, p3);\n        // Avoid division by zero\n        if (d1 < 0.001 || d2 < 0.001 || d3 < 0.001) {\n            path += \" L \".concat(p2.x, \",\").concat(p2.y);\n            continue;\n        }\n        const d1a = Math.pow(d1, alpha);\n        const d2a = Math.pow(d2, alpha);\n        const d3a = Math.pow(d3, alpha);\n        const d1a2 = Math.pow(d1, 2 * alpha);\n        const d2a2 = Math.pow(d2, 2 * alpha);\n        const d3a2 = Math.pow(d3, 2 * alpha);\n        // Control point 1\n        const denom1 = 3 * d1a * (d1a + d2a);\n        const cp1x = denom1 !== 0 ? (d1a2 * p2.x - d2a2 * p0.x + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.x) / denom1 : (p1.x + p2.x) / 2;\n        const cp1y = denom1 !== 0 ? (d1a2 * p2.y - d2a2 * p0.y + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.y) / denom1 : (p1.y + p2.y) / 2;\n        // Control point 2\n        const denom2 = 3 * d3a * (d3a + d2a);\n        const cp2x = denom2 !== 0 ? (d3a2 * p1.x - d2a2 * p3.x + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.x) / denom2 : (p1.x + p2.x) / 2;\n        const cp2y = denom2 !== 0 ? (d3a2 * p1.y - d2a2 * p3.y + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.y) / denom2 : (p1.y + p2.y) / 2;\n        path += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p2.x, \",\").concat(p2.y);\n    }\n    return path;\n}\n// ─── Utility Functions ──────────────────────────────────────────────────────\n/**\n * Parse option index from optionId (e.g., \"r0-opt2\" → 2)\n */ function parseOptionIndex(optionId) {\n    const match = optionId.match(/opt(\\d+)$/);\n    return match ? parseInt(match[1], 10) : 0;\n}\n/**\n * Easing function for smooth animation\n */ function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n}\nconst AnimatedPath = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_s(function AnimatedPath(param) {\n    let { path, color, strokeWidth, dashArray, opacity = 1, delay = 0, duration = 1200 } = param;\n    _s();\n    const pathRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [pathLength, setPathLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Track how much of the path we've already animated (revealed)\n    const animatedLengthRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Animation state: 'idle' | 'preparing' | 'animating'\n    const [animState, setAnimState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    // Store the offset to animate from\n    const [targetOffset, setTargetOffset] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Measure path length when path changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!pathRef.current || !path) return;\n        const totalLength = pathRef.current.getTotalLength();\n        setPathLength(totalLength);\n    }, [\n        path\n    ]);\n    // Detect new segments and trigger animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (pathLength === 0) return;\n        const newSegmentLength = pathLength - animatedLengthRef.current;\n        if (newSegmentLength > 0.5) {\n            // New segment to animate - set up the starting offset\n            setTargetOffset(newSegmentLength);\n            setAnimState(\"preparing\");\n        }\n    }, [\n        pathLength\n    ]);\n    // Handle animation state machine\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (animState === \"preparing\") {\n            // Wait for the \"hidden\" state to render, then start animation\n            const raf = requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    const timer = setTimeout(()=>{\n                        setAnimState(\"animating\");\n                        // Mark this length as animated after the animation completes\n                        setTimeout(()=>{\n                            animatedLengthRef.current = pathLength;\n                            setAnimState(\"idle\");\n                        }, duration);\n                    }, delay);\n                    return ()=>clearTimeout(timer);\n                });\n            });\n            return ()=>cancelAnimationFrame(raf);\n        }\n    }, [\n        animState,\n        pathLength,\n        delay,\n        duration\n    ]);\n    if (!path) return null;\n    // Calculate dash offset based on animation state\n    let dashOffset = 0;\n    if (animState === \"preparing\") {\n        dashOffset = targetOffset; // Hidden - new segment not visible\n    } else if (animState === \"animating\") {\n        dashOffset = 0; // Revealed - animate to this\n    }\n    // When idle, offset is 0 (fully visible)\n    // For animation to work, dasharray must be at least pathLength\n    const effectiveDashArray = \"\".concat(pathLength);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n        ref: pathRef,\n        d: path,\n        fill: \"none\",\n        stroke: color,\n        strokeWidth: strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        strokeDasharray: effectiveDashArray,\n        strokeDashoffset: dashOffset,\n        opacity: opacity,\n        style: {\n            transition: animState === \"animating\" ? \"stroke-dashoffset \".concat(duration, \"ms ease-in-out, opacity 1s ease\") : \"none\"\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 353,\n        columnNumber: 5\n    }, this);\n}, \"Gle3gVkvwGrGIX+aR+6XZv8mfsM=\"));\n_c = AnimatedPath;\n// ─── Main Component ─────────────────────────────────────────────────────────\nconst SongTree = /*#__PURE__*/ _s1((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c1 = _s1(function SongTree(param) {\n    let { rows, paths, currentRowIndex, showPhase, finalePhase, currentFinaleTimeline, factionColors = FACTION_COLORS, audienceTimelines } = param;\n    _s1();\n    // Defensive check: ensure rows exist\n    if (!rows || rows.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: styles.container,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"#999\",\n                    fontSize: \"1.5rem\",\n                    textAlign: \"center\"\n                },\n                children: \"Loading song tree...\"\n            }, void 0, false, {\n                fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                lineNumber: 389,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 388,\n            columnNumber: 7\n        }, this);\n    }\n    // Layout state - always start in grid mode, let useEffect handle transition\n    const [layoutMode, setLayoutMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"grid\");\n    const [layoutProgress, setLayoutProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Generate mock audience timelines for testing (30 users with random paths)\n    const mockTimelines = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const timelines = [];\n        const numRows = rows.length;\n        // Seeded random for reproducibility\n        let seed = 42;\n        const rand = ()=>{\n            seed = (seed * 16807 + 0) % 2147483647;\n            return (seed - 1) / 2147483646;\n        };\n        for(let i = 0; i < 30; i++){\n            const path = [];\n            for(let r = 0; r < numRows; r++){\n                const optionIdx = Math.floor(rand() * OPTIONS_PER_ROW);\n                path.push(\"r\".concat(r, \"-opt\").concat(optionIdx));\n            }\n            timelines.push({\n                userId: \"mock-user-\".concat(i),\n                path: path,\n                figTreeResponse: \"\",\n                harmonicGroup: \"A\"\n            });\n        }\n        return timelines;\n    }, [\n        rows.length\n    ]);\n    // Accumulated audience timelines for finale\n    const [revealedTimelines, setRevealedTimelines] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Use provided timelines, or mock timelines for testing when in finale\n    const effectiveTimelines = audienceTimelines !== null && audienceTimelines !== void 0 ? audienceTimelines : showPhase === \"finale\" ? mockTimelines : [];\n    // Generate stable delta jitter\n    const deltaJitter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>generateDeltaJitter(123, rows.length), [\n        rows.length\n    ]);\n    // Layout configuration\n    const layoutConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            width: SVG_WIDTH,\n            height: SVG_HEIGHT,\n            rows: rows.length,\n            options: OPTIONS_PER_ROW\n        }), [\n        rows.length\n    ]);\n    // Transition animation when entering finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showPhase === \"finale\" && layoutMode !== \"tree\") {\n            setLayoutMode(\"transitioning\");\n            const startTime = performance.now();\n            const animate = (now)=>{\n                const elapsed = now - startTime;\n                const progress = Math.min(elapsed / TRANSITION_DURATION_MS, 1);\n                const eased = easeInOutCubic(progress);\n                setLayoutProgress(eased);\n                if (progress < 1) {\n                    requestAnimationFrame(animate);\n                } else {\n                    setLayoutMode(\"tree\");\n                }\n            };\n            requestAnimationFrame(animate);\n        } else if (showPhase === \"running\" && layoutMode === \"tree\") {\n            // Reset to grid (instant) if returning to running\n            setLayoutMode(\"grid\");\n            setLayoutProgress(0);\n            setRevealedTimelines([]);\n        }\n    }, [\n        showPhase,\n        layoutMode\n    ]);\n    // Accumulate revealed timelines during finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentFinaleTimeline && !revealedTimelines.find((t)=>t.userId === currentFinaleTimeline.userId)) {\n            setRevealedTimelines((prev)=>[\n                    ...prev,\n                    currentFinaleTimeline\n                ]);\n        }\n    }, [\n        currentFinaleTimeline,\n        revealedTimelines\n    ]);\n    // Position function based on layout mode\n    const getPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((row, option)=>{\n        if (layoutMode === \"grid\" || layoutProgress === 0) {\n            return gridPosition(row, option, layoutConfig);\n        }\n        if (layoutMode === \"tree\" || layoutProgress === 1) {\n            return deltaPosition(row, option, layoutConfig, deltaJitter);\n        }\n        return interpolatedPosition(row, option, layoutConfig, layoutProgress, deltaJitter);\n    }, [\n        layoutMode,\n        layoutProgress,\n        layoutConfig,\n        deltaJitter\n    ]);\n    // Build full path strings for smooth Catmull-Rom curves\n    const factionPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.factionPath.length === 0) return \"\";\n        const points = paths.factionPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.factionPath,\n        getPosition\n    ]);\n    const popularPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.popularPath.length === 0) return \"\";\n        const points = paths.popularPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.popularPath,\n        getPosition\n    ]);\n    // Build audience timeline path strings\n    const audiencePathStrings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return effectiveTimelines.map((timeline, idx)=>{\n            const points = timeline.path.map((optionId, rowIdx)=>{\n                const optionIdx = parseOptionIndex(optionId);\n                return getPosition(rowIdx, optionIdx);\n            });\n            return {\n                userId: timeline.userId,\n                path: catmullRomPath(points),\n                // Determine faction from userId - for now use modulo as placeholder\n                // In production, this would come from user data\n                factionIndex: idx % 4\n            };\n        });\n    }, [\n        effectiveTimelines,\n        getPosition\n    ]);\n    const isTreeMode = layoutMode === \"tree\" || layoutProgress > 0;\n    const isTransitioning = layoutMode === \"transitioning\";\n    const hasAudiencePaths = effectiveTimelines.length > 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: styles.container,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n            style: styles.svg,\n            viewBox: \"0 0 \".concat(SVG_WIDTH, \" \").concat(SVG_HEIGHT),\n            preserveAspectRatio: \"xMidYMid meet\",\n            children: [\n                finalePhase === \"individual_timelines\" && audiencePathStrings.map((ap, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                        path: ap.path,\n                        color: factionColors[ap.factionIndex] || FACTION_COLORS[0],\n                        strokeWidth: 2,\n                        opacity: 0.5,\n                        delay: idx * 100,\n                        duration: 1000\n                    }, ap.userId, false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 550,\n                        columnNumber: 13\n                    }, this)),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: popularPathString,\n                    color: \"#666\",\n                    strokeWidth: 3,\n                    dashArray: \"8 4\",\n                    opacity: hasAudiencePaths ? 0.2 : 0.5,\n                    delay: 0,\n                    duration: paths.popularPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 562,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: factionPathString,\n                    color: \"#fff\",\n                    strokeWidth: 4,\n                    opacity: hasAudiencePaths ? 0.15 : 1,\n                    delay: 0,\n                    duration: paths.factionPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 573,\n                    columnNumber: 9\n                }, this),\n                rows.map((row)=>row.options.map((option, optIdx)=>{\n                        const pos = getPosition(row.index, optIdx);\n                        const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                        const isCommitted = row.committedOption === option.id;\n                        const isInFactionPath = paths.factionPath.includes(option.id);\n                        const isWinner = visible && (isCommitted || isInFactionPath);\n                        const isCurrent = row.index === currentRowIndex && row.phase !== \"pending\";\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: WINNER_RADIUS + 6,\n                                    fill: \"none\",\n                                    stroke: \"#fff\",\n                                    strokeWidth: 1,\n                                    opacity: 0.12,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 596,\n                                    columnNumber: 19\n                                }, this),\n                                isCurrent && !isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: DOT_RADIUS + 8,\n                                    fill: \"none\",\n                                    stroke: \"#4ade80\",\n                                    strokeWidth: 2,\n                                    opacity: 0.4,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 611,\n                                    columnNumber: 19\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: isWinner ? WINNER_RADIUS : DOT_RADIUS,\n                                    fill: !visible ? \"#1a1a22\" : isWinner ? \"#fff\" : \"#3a3a44\",\n                                    stroke: !visible ? \"#2a2a32\" : isWinner ? \"#fff\" : \"#4a4a54\",\n                                    strokeWidth: visible ? 1.5 : 0.5,\n                                    opacity: visible ? 1 : 0.35,\n                                    style: {\n                                        transition: isTransitioning ? \"r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out, r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 625,\n                                    columnNumber: 17\n                                }, this),\n                                visible && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: pos.x,\n                                    y: pos.y + 1,\n                                    textAnchor: \"middle\",\n                                    dominantBaseline: \"central\",\n                                    fontSize: 9,\n                                    fontWeight: 700,\n                                    fill: isWinner ? \"#0b0b0f\" : \"#666\",\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\",\n                                        pointerEvents: \"none\"\n                                    },\n                                    children: String.fromCharCode(65 + optIdx)\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 641,\n                                    columnNumber: 19\n                                }, this)\n                            ]\n                        }, option.id, true, {\n                            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                            lineNumber: 593,\n                            columnNumber: 15\n                        }, this);\n                    })),\n                rows.map((row)=>{\n                    const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                    if (!visible) return null;\n                    const leftPos = getPosition(row.index, 0);\n                    const labelX = isTreeMode ? Math.min(leftPos.x, getPosition(row.index, OPTIONS_PER_ROW - 1).x) - 30 : leftPos.x - 40;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                        x: labelX,\n                        y: leftPos.y + 1,\n                        textAnchor: \"end\",\n                        dominantBaseline: \"central\",\n                        fontSize: 10,\n                        fill: \"#444\",\n                        style: {\n                            transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\"\n                        },\n                        children: row.label || \"R\".concat(row.index + 1)\n                    }, \"label-\".concat(row.index), false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 673,\n                        columnNumber: 13\n                    }, this);\n                })\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 542,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 541,\n        columnNumber: 5\n    }, this);\n}, \"guEy+xxSdFmLvFrSDXYY5p7qbhE=\")), \"guEy+xxSdFmLvFrSDXYY5p7qbhE=\");\n_c2 = SongTree;\n// ─── Styles ─────────────────────────────────────────────────────────────────\nconst styles = {\n    container: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        overflow: \"hidden\"\n    },\n    svg: {\n        width: \"90%\",\n        height: \"90%\",\n        maxWidth: SVG_WIDTH,\n        maxHeight: SVG_HEIGHT\n    }\n};\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AnimatedPath\");\n$RefreshReg$(_c1, \"SongTree$memo\");\n$RefreshReg$(_c2, \"SongTree\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU29uZ1RyZWUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUM7O0FBSStFO0FBOENoRiwrRUFBK0U7QUFFL0UsTUFBTU0sWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGtCQUFrQjtBQUV4QixNQUFNQyxpQkFBaUI7SUFBQztJQUFXO0lBQVc7SUFBVztDQUFVO0FBQ25FLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCO0FBRXRCLHNCQUFzQjtBQUN0QixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsbUJBQW1CO0FBRXpCLHNCQUFzQjtBQUN0QixNQUFNQyx5QkFBeUI7QUFFL0IsK0VBQStFO0FBRS9FOzs7Q0FHQyxHQUNELFNBQVNDLGFBQWFDLEdBQVcsRUFBRUMsTUFBYyxFQUFFQyxNQUFvQjtJQUNyRSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO0lBQzFCLE1BQU1HLElBQUlGLFFBQVEsSUFBSVAsbUJBQW1CLE1BQU1LLFNBQVNMO0lBQ3hELE1BQU1VLElBQUlGLFNBQVMsS0FBS0osTUFBTUg7SUFDOUIsT0FBTztRQUFFUTtRQUFHQztJQUFFO0FBQ2hCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLGNBQ1BQLEdBQVcsRUFDWEMsTUFBYyxFQUNkQyxNQUFvQixFQUNwQk0sTUFBa0Q7SUFFbEQsTUFBTSxFQUFFTCxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUUxQixxRUFBcUU7SUFDckUsTUFBTU8sS0FBS0wsU0FBUztJQUNwQixNQUFNTSxPQUFPO0lBQ2IsTUFBTUMsU0FBU0YsS0FBS0M7SUFFcEIsaUVBQWlFO0lBQ2pFLE1BQU1FLElBQUlaLE1BQU9FLENBQUFBLE9BQU9XLElBQUksR0FBRyxJQUFJLHdCQUF3QjtJQUMzRCxJQUFJUCxJQUFJRyxLQUFLRyxJQUFJRDtJQUVqQiwwRUFBMEU7SUFDMUUsTUFBTUcsU0FBUyxL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LEtBQUssSUFBSSxJQUFrQixPQUFkMUwsSUFBSW1LLEtBQUssR0FBRzt1QkFYekIsU0FBbUIsT0FBVm5LLElBQUltSyxLQUFLOzs7OztnQkFjN0I7Ozs7Ozs7Ozs7OztBQUlSLHFFQUFHOztBQUVILCtFQUErRTtBQUUvRSxNQUFNcEQsU0FBUztJQUNiQyxXQUFXO1FBQ1QyRSxVQUFVO1FBQ1Z4TCxPQUFPO1FBQ1BDLFFBQVE7UUFDUndMLFNBQVM7UUFDVEMsWUFBWTtRQUNaQyxnQkFBZ0I7UUFDaEJDLFVBQVU7SUFDWjtJQUVBbEMsS0FBSztRQUNIMUosT0FBTztRQUNQQyxRQUFRO1FBQ1I0TCxVQUFVMU07UUFDVjJNLFdBQVcxTTtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Tb25nVHJlZS50c3g/YjllMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNvbmdUcmVlIENvbXBvbmVudFxuICpcbiAqIENvcmUgdmlzdWFsaXphdGlvbiBzaG93aW5nIHRoZSBzb25nIGNvbnN0cnVjdGlvbiBhcyBhIHRyZWUgb2Ygb3B0aW9ucy5cbiAqIERpc3BsYXlzIGR1YWwgcGF0aHM6IGZhY3Rpb24gcGF0aCAoc29saWQpIGFuZCBwb3B1bGFyIHBhdGggKGdob3N0L2Rhc2hlZCkuXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEJvdHRvbS10by10b3Agcm93IHByb2dyZXNzaW9uIChyb3cgMCBhdCBib3R0b20pXG4gKiAtIEdyaWQgbGF5b3V0IGR1cmluZyAncnVubmluZycgcGhhc2VcbiAqIC0gUml2ZXIgZGVsdGEgbGF5b3V0IGR1cmluZyAnZmluYWxlJyBwaGFzZSAodGlnaHQgcm9vdCwgb3JnYW5pY2FsbHkgc3ByZWFkaW5nIHRyaWJ1dGFyaWVzKVxuICogLSBTbW9vdGggQ2F0bXVsbC1Sb20gY3VydmVkIHBhdGhzXG4gKiAtIEFuaW1hdGVkIGluZGl2aWR1YWwgYXVkaWVuY2UgcGF0aHMgZHVyaW5nIGZpbmFsZVxuICovXG5cbid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgbWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgRHVhbFBhdGhzLCBPcHRpb25JZCwgUm93UGhhc2UsIFNob3dDb25maWcsIFNob3dQaGFzZSwgRmluYWxlVGltZWxpbmUgfSBmcm9tICdAL2NvbmR1Y3Rvci90eXBlcyc7XG5cbi8vIOKUgOKUgOKUgCBUeXBlcyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZXhwb3J0IGludGVyZmFjZSBTb25nVHJlZVByb3BzIHtcbiAgcm93czogQXJyYXk8e1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgb3B0aW9uczogQXJyYXk8e1xuICAgICAgaWQ6IE9wdGlvbklkO1xuICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgIGF1ZGlvUmVmOiBzdHJpbmc7XG4gICAgICBoYXJtb25pY0dyb3VwPzogc3RyaW5nO1xuICAgIH0+O1xuICAgIHBoYXNlOiBSb3dQaGFzZTtcbiAgICBjb21taXR0ZWRPcHRpb246IE9wdGlvbklkIHwgbnVsbDtcbiAgICBjdXJyZW50QXVkaXRpb25JbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgICBhdHRlbXB0czogbnVtYmVyO1xuICB9PjtcbiAgcGF0aHM6IER1YWxQYXRocztcbiAgY3VycmVudFJvd0luZGV4OiBudW1iZXI7XG4gIGNvbmZpZz86IFNob3dDb25maWc7XG4gIC8vIE5ldyBwcm9wcyBmb3IgZmluYWxlIHN1cHBvcnRcbiAgc2hvd1BoYXNlOiBTaG93UGhhc2U7XG4gIGZpbmFsZVBoYXNlPzogJ3BvcHVsYXJfc29uZycgfCAnaW5kaXZpZHVhbF90aW1lbGluZXMnIHwgbnVsbDtcbiAgY3VycmVudEZpbmFsZVRpbWVsaW5lPzogRmluYWxlVGltZWxpbmUgfCBudWxsO1xuICBmYWN0aW9uQ29sb3JzPzogc3RyaW5nW107XG4gIGF1ZGllbmNlVGltZWxpbmVzPzogRmluYWxlVGltZWxpbmVbXTtcbn1cblxuaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBMYXlvdXRDb25maWcge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgcm93czogbnVtYmVyO1xuICBvcHRpb25zOiBudW1iZXI7XG59XG5cbnR5cGUgTGF5b3V0TW9kZSA9ICdncmlkJyB8ICd0cmVlJyB8ICd0cmFuc2l0aW9uaW5nJztcblxuLy8g4pSA4pSA4pSAIENvbnN0YW50cyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuY29uc3QgU1ZHX1dJRFRIID0gODAwO1xuY29uc3QgU1ZHX0hFSUdIVCA9IDcwMDtcbmNvbnN0IE9QVElPTlNfUEVSX1JPVyA9IDQ7XG5cbmNvbnN0IEZBQ1RJT05fQ09MT1JTID0gWycjZTA1YzVjJywgJyM1Y2I4ZTAnLCAnIzVjZTA4YScsICcjZTBjNTVjJ107XG5jb25zdCBET1RfUkFESVVTID0gODtcbmNvbnN0IFdJTk5FUl9SQURJVVMgPSAxMTtcblxuLy8gR3JpZCBsYXlvdXQgc3BhY2luZ1xuY29uc3QgR1JJRF9DT0xfU1BBQ0lORyA9IDcwO1xuY29uc3QgR1JJRF9ST1dfU1BBQ0lORyA9IDU2O1xuXG4vLyBUcmFuc2l0aW9uIGR1cmF0aW9uXG5jb25zdCBUUkFOU0lUSU9OX0RVUkFUSU9OX01TID0gMTUwMDtcblxuLy8g4pSA4pSA4pSAIExheW91dCBGdW5jdGlvbnMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbi8qKlxuICogR3JpZCBwb3NpdGlvbiAtIGxpbmVhciBsYXlvdXQgdXNlZCBkdXJpbmcgJ3J1bm5pbmcnIHBoYXNlXG4gKiBCb3R0b20tdG8tdG9wOiByb3cgMCBhdCBib3R0b20sIGhpZ2hlciByb3dzIGF0IHRvcFxuICovXG5mdW5jdGlvbiBncmlkUG9zaXRpb24ocm93OiBudW1iZXIsIG9wdGlvbjogbnVtYmVyLCBjb25maWc6IExheW91dENvbmZpZyk6IFBvaW50IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb25maWc7XG4gIGNvbnN0IHggPSB3aWR0aCAvIDIgLSBHUklEX0NPTF9TUEFDSU5HICogMS41ICsgb3B0aW9uICogR1JJRF9DT0xfU1BBQ0lORztcbiAgY29uc3QgeSA9IGhlaWdodCAtIDcwIC0gcm93ICogR1JJRF9ST1dfU1BBQ0lORztcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG4vKipcbiAqIERlbHRhIHBvc2l0aW9uIC0gcml2ZXIgZGVsdGEgLyB0cmlidXRhcnkgbGF5b3V0IHVzZWQgZHVyaW5nICdmaW5hbGUnIHBoYXNlXG4gKiBTaW5nbGUgc291cmNlIGF0IGJvdHRvbSwgcGF0aHMgYnJhbmNoIG91dHdhcmQgd2l0aCBvcmdhbmljIHNwcmVhZC5cbiAqIEppdHRlciBpbmNyZWFzZXMgd2l0aCByb3cgZGVwdGggZm9yIG5hdHVyYWwgYXN5bW1ldHJ5LlxuICovXG5mdW5jdGlvbiBkZWx0YVBvc2l0aW9uKFxuICByb3c6IG51bWJlcixcbiAgb3B0aW9uOiBudW1iZXIsXG4gIGNvbmZpZzogTGF5b3V0Q29uZmlnLFxuICBqaXR0ZXI6IFJlY29yZDxzdHJpbmcsIHsgZHg6IG51bWJlcjsgZHk6IG51bWJlciB9PlxuKTogUG9pbnQge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbmZpZztcblxuICAvLyBCb3R0b20tdG8tdG9wIFkgcG9zaXRpb25pbmcgd2l0aCBpbmNyZWFzaW5nIHNwYWNpbmcgdG93YXJkIHRoZSB0b3BcbiAgY29uc3QgeTAgPSBoZWlnaHQgLSA2MDtcbiAgY29uc3QgeVRvcCA9IDYwO1xuICBjb25zdCB0b3RhbEggPSB5MCAtIHlUb3A7XG5cbiAgLy8gVXNlIGEgc2xpZ2h0IHBvd2VyIGN1cnZlIHNvIHVwcGVyIHJvd3MgZ2V0IG1vcmUgcm9vbSB0byBzcHJlYWRcbiAgY29uc3QgdCA9IHJvdyAvIChjb25maWcucm93cyAtIDEpOyAvLyAwIGF0IGJvdHRvbSwgMSBhdCB0b3BcbiAgbGV0IHkgPSB5MCAtIHQgKiB0b3RhbEg7XG5cbiAgLy8gU3ByZWFkIGluY3JlYXNlcyBhcyBhIHBvd2VyIGN1cnZlIOKAlCB0aWdodCBhdCB0aGUgcm9vdCwgd2lkZSBhdCB0aGUgdGlwc1xuICBjb25zdCBzcHJlYWQgPSAyMCArIE1hdGgucG93KHJvdywgMS44KSAqIDE0O1xuXG4gIC8vIDQgb3B0aW9ucyBldmVubHkgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBzcHJlYWRcbiAgY29uc3Qgb2Zmc2V0cyA9IFstMS41LCAtMC41LCAwLjUsIDEuNV07XG4gIGxldCB4ID0gd2lkdGggLyAyICsgb2Zmc2V0c1tvcHRpb25dICogc3ByZWFkO1xuXG4gIC8vIEFwcGx5IHN0YWJsZSBqaXR0ZXIg4oCUIGluY3JlYXNlcyB3aXRoIHJvdyBmb3Igb3JnYW5pYyBmZWVsXG4gIGNvbnN0IGtleSA9IGAke3Jvd30tJHtvcHRpb259YDtcbiAgaWYgKGppdHRlcltrZXldKSB7XG4gICAgeCArPSBqaXR0ZXJba2V5XS5keDtcbiAgICB5ICs9IGppdHRlcltrZXldLmR5O1xuICB9XG5cbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuXG4vKipcbiAqIEludGVycG9sYXRlIGJldHdlZW4gZ3JpZCBhbmQgdHJlZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVkUG9zaXRpb24oXG4gIHJvdzogbnVtYmVyLFxuICBvcHRpb246IG51bWJlcixcbiAgY29uZmlnOiBMYXlvdXRDb25maWcsXG4gIHByb2dyZXNzOiBudW1iZXIsXG4gIGppdHRlcjogUmVjb3JkPHN0cmluZywgeyBkeDogbnVtYmVyOyBkeTogbnVtYmVyIH0+XG4pOiBQb2ludCB7XG4gIGNvbnN0IGdyaWRQb3MgPSBncmlkUG9zaXRpb24ocm93LCBvcHRpb24sIGNvbmZpZyk7XG4gIGNvbnN0IGRlbHRhUG9zID0gZGVsdGFQb3NpdGlvbihyb3csIG9wdGlvbiwgY29uZmlnLCBqaXR0ZXIpO1xuXG4gIHJldHVybiB7XG4gICAgeDogZ3JpZFBvcy54ICsgKGRlbHRhUG9zLnggLSBncmlkUG9zLngpICogcHJvZ3Jlc3MsXG4gICAgeTogZ3JpZFBvcy55ICsgKGRlbHRhUG9zLnkgLSBncmlkUG9zLnkpICogcHJvZ3Jlc3MsXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgc3RhYmxlIGppdHRlciBmb3IgZGVsdGEgbGF5b3V0LlxuICogSml0dGVyIG1hZ25pdHVkZSBpbmNyZWFzZXMgd2l0aCByb3cgaW5kZXgg4oCUIHRpZ2h0IGF0IHJvb3QsIGxvb3NlIGF0IHRpcHMuXG4gKiBSb3cgMCBnZXRzIG5vIGppdHRlciAoY29tbW9uIHNvdXJjZSksIGhpZ2hlciByb3dzIHNwcmVhZCBvcmdhbmljYWxseS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVEZWx0YUppdHRlcihzZWVkOiBudW1iZXIsIG51bVJvd3M6IG51bWJlcik6IFJlY29yZDxzdHJpbmcsIHsgZHg6IG51bWJlcjsgZHk6IG51bWJlciB9PiB7XG4gIGxldCBzID0gc2VlZDtcbiAgY29uc3QgcmFuZCA9ICgpID0+IHtcbiAgICBzID0gKHMgKiAxNjgwNyArIDApICUgMjE0NzQ4MzY0NztcbiAgICByZXR1cm4gKHMgLSAxKSAvIDIxNDc0ODM2NDY7XG4gIH07XG5cbiAgY29uc3Qgaml0dGVyOiBSZWNvcmQ8c3RyaW5nLCB7IGR4OiBudW1iZXI7IGR5OiBudW1iZXIgfT4gPSB7fTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbnVtUm93czsgcm93KyspIHtcbiAgICBmb3IgKGxldCBvcHQgPSAwOyBvcHQgPCBPUFRJT05TX1BFUl9ST1c7IG9wdCsrKSB7XG4gICAgICAvLyBTY2FsZSBqaXR0ZXI6IG5vbmUgYXQgcm93IDAsIGluY3JlYXNpbmcgdG93YXJkIHRvcCByb3dzXG4gICAgICBjb25zdCBtYWduaXR1ZGUgPSByb3cgPD0gMSA/IDAgOiBNYXRoLnBvdyhyb3cgLSAxLCAxLjIpICogNDtcbiAgICAgIGppdHRlcltgJHtyb3d9LSR7b3B0fWBdID0ge1xuICAgICAgICBkeDogKHJhbmQoKSAtIDAuNSkgKiBtYWduaXR1ZGUsXG4gICAgICAgIGR5OiAocmFuZCgpIC0gMC41KSAqIG1hZ25pdHVkZSAqIDAuNixcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBqaXR0ZXI7XG59XG5cbi8vIOKUgOKUgOKUgCBDdXJ2ZSBHZW5lcmF0aW9uIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG4vKipcbiAqIENhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UocDE6IFBvaW50LCBwMjogUG9pbnQpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5zcXJ0KChwMi54IC0gcDEueCkgKiogMiArIChwMi55IC0gcDEueSkgKiogMik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBDYXRtdWxsLVJvbSBzcGxpbmUgcGF0aCBzdHJpbmdcbiAqIEFscGhhIDAuNSA9IGNlbnRyaXBldGFsIChhdm9pZHMgY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucylcbiAqL1xuZnVuY3Rpb24gY2F0bXVsbFJvbVBhdGgocG9pbnRzOiBQb2ludFtdLCBhbHBoYTogbnVtYmVyID0gMC41KTogc3RyaW5nIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDEpIHJldHVybiBgTSAke3BvaW50c1swXS54fSwke3BvaW50c1swXS55fWA7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGBNICR7cG9pbnRzWzBdLnh9LCR7cG9pbnRzWzBdLnl9IEwgJHtwb2ludHNbMV0ueH0sJHtwb2ludHNbMV0ueX1gO1xuICB9XG5cbiAgLy8gRHVwbGljYXRlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBmb3IgZW5kIHRhbmdlbnRzXG4gIGNvbnN0IGV4dGVuZGVkID0gW3BvaW50c1swXSwgLi4ucG9pbnRzLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdXTtcblxuICBsZXQgcGF0aCA9IGBNICR7cG9pbnRzWzBdLnh9LCR7cG9pbnRzWzBdLnl9YDtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZGVkLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIGNvbnN0IHAwID0gZXh0ZW5kZWRbaSAtIDFdO1xuICAgIGNvbnN0IHAxID0gZXh0ZW5kZWRbaV07XG4gICAgY29uc3QgcDIgPSBleHRlbmRlZFtpICsgMV07XG4gICAgY29uc3QgcDMgPSBleHRlbmRlZFtpICsgMl07XG5cbiAgICBjb25zdCBkMSA9IGRpc3RhbmNlKHAwLCBwMSk7XG4gICAgY29uc3QgZDIgPSBkaXN0YW5jZShwMSwgcDIpO1xuICAgIGNvbnN0IGQzID0gZGlzdGFuY2UocDIsIHAzKTtcblxuICAgIC8vIEF2b2lkIGRpdmlzaW9uIGJ5IHplcm9cbiAgICBpZiAoZDEgPCAwLjAwMSB8fCBkMiA8IDAuMDAxIHx8IGQzIDwgMC4wMDEpIHtcbiAgICAgIHBhdGggKz0gYCBMICR7cDIueH0sJHtwMi55fWA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBkMWEgPSBNYXRoLnBvdyhkMSwgYWxwaGEpO1xuICAgIGNvbnN0IGQyYSA9IE1hdGgucG93KGQyLCBhbHBoYSk7XG4gICAgY29uc3QgZDNhID0gTWF0aC5wb3coZDMsIGFscGhhKTtcblxuICAgIGNvbnN0IGQxYTIgPSBNYXRoLnBvdyhkMSwgMiAqIGFscGhhKTtcbiAgICBjb25zdCBkMmEyID0gTWF0aC5wb3coZDIsIDIgKiBhbHBoYSk7XG4gICAgY29uc3QgZDNhMiA9IE1hdGgucG93KGQzLCAyICogYWxwaGEpO1xuXG4gICAgLy8gQ29udHJvbCBwb2ludCAxXG4gICAgY29uc3QgZGVub20xID0gMyAqIGQxYSAqIChkMWEgKyBkMmEpO1xuICAgIGNvbnN0IGNwMXggPSBkZW5vbTEgIT09IDBcbiAgICAgID8gKGQxYTIgKiBwMi54IC0gZDJhMiAqIHAwLnggKyAoMiAqIGQxYTIgKyAzICogZDFhICogZDJhICsgZDJhMikgKiBwMS54KSAvIGRlbm9tMVxuICAgICAgOiAocDEueCArIHAyLngpIC8gMjtcbiAgICBjb25zdCBjcDF5ID0gZGVub20xICE9PSAwXG4gICAgICA/IChkMWEyICogcDIueSAtIGQyYTIgKiBwMC55ICsgKDIgKiBkMWEyICsgMyAqIGQxYSAqIGQyYSArIGQyYTIpICogcDEueSkgLyBkZW5vbTFcbiAgICAgIDogKHAxLnkgKyBwMi55KSAvIDI7XG5cbiAgICAvLyBDb250cm9sIHBvaW50IDJcbiAgICBjb25zdCBkZW5vbTIgPSAzICogZDNhICogKGQzYSArIGQyYSk7XG4gICAgY29uc3QgY3AyeCA9IGRlbm9tMiAhPT0gMFxuICAgICAgPyAoZDNhMiAqIHAxLnggLSBkMmEyICogcDMueCArICgyICogZDNhMiArIDMgKiBkM2EgKiBkMmEgKyBkMmEyKSAqIHAyLngpIC8gZGVub20yXG4gICAgICA6IChwMS54ICsgcDIueCkgLyAyO1xuICAgIGNvbnN0IGNwMnkgPSBkZW5vbTIgIT09IDBcbiAgICAgID8gKGQzYTIgKiBwMS55IC0gZDJhMiAqIHAzLnkgKyAoMiAqIGQzYTIgKyAzICogZDNhICogZDJhICsgZDJhMikgKiBwMi55KSAvIGRlbm9tMlxuICAgICAgOiAocDEueSArIHAyLnkpIC8gMjtcblxuICAgIHBhdGggKz0gYCBDICR7Y3AxeH0sJHtjcDF5fSAke2NwMnh9LCR7Y3AyeX0gJHtwMi54fSwke3AyLnl9YDtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG4vLyDilIDilIDilIAgVXRpbGl0eSBGdW5jdGlvbnMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbi8qKlxuICogUGFyc2Ugb3B0aW9uIGluZGV4IGZyb20gb3B0aW9uSWQgKGUuZy4sIFwicjAtb3B0MlwiIOKGkiAyKVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkOiBPcHRpb25JZCk6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoID0gb3B0aW9uSWQubWF0Y2goL29wdChcXGQrKSQvKTtcbiAgcmV0dXJuIG1hdGNoID8gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA6IDA7XG59XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9uIGZvciBzbW9vdGggYW5pbWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6IDEgLSBNYXRoLnBvdygtMiAqIHQgKyAyLCAzKSAvIDI7XG59XG5cbi8vIOKUgOKUgOKUgCBBbmltYXRlZFBhdGggQ29tcG9uZW50IOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG5pbnRlcmZhY2UgQW5pbWF0ZWRQYXRoUHJvcHMge1xuICBwYXRoOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIHN0cm9rZVdpZHRoOiBudW1iZXI7XG4gIGRhc2hBcnJheT86IHN0cmluZztcbiAgb3BhY2l0eT86IG51bWJlcjtcbiAgZGVsYXk/OiBudW1iZXI7XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xufVxuXG5jb25zdCBBbmltYXRlZFBhdGggPSBtZW1vKGZ1bmN0aW9uIEFuaW1hdGVkUGF0aCh7XG4gIHBhdGgsXG4gIGNvbG9yLFxuICBzdHJva2VXaWR0aCxcbiAgZGFzaEFycmF5LFxuICBvcGFjaXR5ID0gMSxcbiAgZGVsYXkgPSAwLFxuICBkdXJhdGlvbiA9IDEyMDAsXG59OiBBbmltYXRlZFBhdGhQcm9wcykge1xuICBjb25zdCBwYXRoUmVmID0gdXNlUmVmPFNWR1BhdGhFbGVtZW50PihudWxsKTtcbiAgY29uc3QgW3BhdGhMZW5ndGgsIHNldFBhdGhMZW5ndGhdID0gdXNlU3RhdGUoMCk7XG4gIC8vIFRyYWNrIGhvdyBtdWNoIG9mIHRoZSBwYXRoIHdlJ3ZlIGFscmVhZHkgYW5pbWF0ZWQgKHJldmVhbGVkKVxuICBjb25zdCBhbmltYXRlZExlbmd0aFJlZiA9IHVzZVJlZigwKTtcbiAgLy8gQW5pbWF0aW9uIHN0YXRlOiAnaWRsZScgfCAncHJlcGFyaW5nJyB8ICdhbmltYXRpbmcnXG4gIGNvbnN0IFthbmltU3RhdGUsIHNldEFuaW1TdGF0ZV0gPSB1c2VTdGF0ZTwnaWRsZScgfCAncHJlcGFyaW5nJyB8ICdhbmltYXRpbmcnPignaWRsZScpO1xuICAvLyBTdG9yZSB0aGUgb2Zmc2V0IHRvIGFuaW1hdGUgZnJvbVxuICBjb25zdCBbdGFyZ2V0T2Zmc2V0LCBzZXRUYXJnZXRPZmZzZXRdID0gdXNlU3RhdGUoMCk7XG5cbiAgLy8gTWVhc3VyZSBwYXRoIGxlbmd0aCB3aGVuIHBhdGggY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcGF0aFJlZi5jdXJyZW50IHx8ICFwYXRoKSByZXR1cm47XG4gICAgY29uc3QgdG90YWxMZW5ndGggPSBwYXRoUmVmLmN1cnJlbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBzZXRQYXRoTGVuZ3RoKHRvdGFsTGVuZ3RoKTtcbiAgfSwgW3BhdGhdKTtcblxuICAvLyBEZXRlY3QgbmV3IHNlZ21lbnRzIGFuZCB0cmlnZ2VyIGFuaW1hdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwYXRoTGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBuZXdTZWdtZW50TGVuZ3RoID0gcGF0aExlbmd0aCAtIGFuaW1hdGVkTGVuZ3RoUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAobmV3U2VnbWVudExlbmd0aCA+IDAuNSkge1xuICAgICAgLy8gTmV3IHNlZ21lbnQgdG8gYW5pbWF0ZSAtIHNldCB1cCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gICAgICBzZXRUYXJnZXRPZmZzZXQobmV3U2VnbWVudExlbmd0aCk7XG4gICAgICBzZXRBbmltU3RhdGUoJ3ByZXBhcmluZycpO1xuICAgIH1cbiAgfSwgW3BhdGhMZW5ndGhdKTtcblxuICAvLyBIYW5kbGUgYW5pbWF0aW9uIHN0YXRlIG1hY2hpbmVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYW5pbVN0YXRlID09PSAncHJlcGFyaW5nJykge1xuICAgICAgLy8gV2FpdCBmb3IgdGhlIFwiaGlkZGVuXCIgc3RhdGUgdG8gcmVuZGVyLCB0aGVuIHN0YXJ0IGFuaW1hdGlvblxuICAgICAgY29uc3QgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0QW5pbVN0YXRlKCdhbmltYXRpbmcnKTtcbiAgICAgICAgICAgIC8vIE1hcmsgdGhpcyBsZW5ndGggYXMgYW5pbWF0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBhbmltYXRlZExlbmd0aFJlZi5jdXJyZW50ID0gcGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgc2V0QW5pbVN0YXRlKCdpZGxlJyk7XG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgfVxuICB9LCBbYW5pbVN0YXRlLCBwYXRoTGVuZ3RoLCBkZWxheSwgZHVyYXRpb25dKTtcblxuICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gIC8vIENhbGN1bGF0ZSBkYXNoIG9mZnNldCBiYXNlZCBvbiBhbmltYXRpb24gc3RhdGVcbiAgbGV0IGRhc2hPZmZzZXQgPSAwO1xuICBpZiAoYW5pbVN0YXRlID09PSAncHJlcGFyaW5nJykge1xuICAgIGRhc2hPZmZzZXQgPSB0YXJnZXRPZmZzZXQ7IC8vIEhpZGRlbiAtIG5ldyBzZWdtZW50IG5vdCB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoYW5pbVN0YXRlID09PSAnYW5pbWF0aW5nJykge1xuICAgIGRhc2hPZmZzZXQgPSAwOyAvLyBSZXZlYWxlZCAtIGFuaW1hdGUgdG8gdGhpc1xuICB9XG4gIC8vIFdoZW4gaWRsZSwgb2Zmc2V0IGlzIDAgKGZ1bGx5IHZpc2libGUpXG5cbiAgLy8gRm9yIGFuaW1hdGlvbiB0byB3b3JrLCBkYXNoYXJyYXkgbXVzdCBiZSBhdCBsZWFzdCBwYXRoTGVuZ3RoXG4gIGNvbnN0IGVmZmVjdGl2ZURhc2hBcnJheSA9IGAke3BhdGhMZW5ndGh9YDtcblxuICByZXR1cm4gKFxuICAgIDxwYXRoXG4gICAgICByZWY9e3BhdGhSZWZ9XG4gICAgICBkPXtwYXRofVxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgc3Ryb2tlPXtjb2xvcn1cbiAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17ZWZmZWN0aXZlRGFzaEFycmF5fVxuICAgICAgc3Ryb2tlRGFzaG9mZnNldD17ZGFzaE9mZnNldH1cbiAgICAgIG9wYWNpdHk9e29wYWNpdHl9XG4gICAgICBzdHlsZT17e1xuICAgICAgICB0cmFuc2l0aW9uOiBhbmltU3RhdGUgPT09ICdhbmltYXRpbmcnXG4gICAgICAgICAgPyBgc3Ryb2tlLWRhc2hvZmZzZXQgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dCwgb3BhY2l0eSAxcyBlYXNlYFxuICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG5cbi8vIOKUgOKUgOKUgCBNYWluIENvbXBvbmVudCDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZXhwb3J0IGNvbnN0IFNvbmdUcmVlID0gbWVtbyhmdW5jdGlvbiBTb25nVHJlZSh7XG4gIHJvd3MsXG4gIHBhdGhzLFxuICBjdXJyZW50Um93SW5kZXgsXG4gIHNob3dQaGFzZSxcbiAgZmluYWxlUGhhc2UsXG4gIGN1cnJlbnRGaW5hbGVUaW1lbGluZSxcbiAgZmFjdGlvbkNvbG9ycyA9IEZBQ1RJT05fQ09MT1JTLFxuICBhdWRpZW5jZVRpbWVsaW5lcyxcbn06IFNvbmdUcmVlUHJvcHMpIHtcbiAgLy8gRGVmZW5zaXZlIGNoZWNrOiBlbnN1cmUgcm93cyBleGlzdFxuICBpZiAoIXJvd3MgfHwgcm93cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6ICcjOTk5JywgZm9udFNpemU6ICcxLjVyZW0nLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxuICAgICAgICAgIExvYWRpbmcgc29uZyB0cmVlLi4uXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIExheW91dCBzdGF0ZSAtIGFsd2F5cyBzdGFydCBpbiBncmlkIG1vZGUsIGxldCB1c2VFZmZlY3QgaGFuZGxlIHRyYW5zaXRpb25cbiAgY29uc3QgW2xheW91dE1vZGUsIHNldExheW91dE1vZGVdID0gdXNlU3RhdGU8TGF5b3V0TW9kZT4oJ2dyaWQnKTtcbiAgY29uc3QgW2xheW91dFByb2dyZXNzLCBzZXRMYXlvdXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBHZW5lcmF0ZSBtb2NrIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgdGVzdGluZyAoMzAgdXNlcnMgd2l0aCByYW5kb20gcGF0aHMpXG4gIGNvbnN0IG1vY2tUaW1lbGluZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB0aW1lbGluZXM6IEZpbmFsZVRpbWVsaW5lW10gPSBbXTtcbiAgICBjb25zdCBudW1Sb3dzID0gcm93cy5sZW5ndGg7XG5cbiAgICAvLyBTZWVkZWQgcmFuZG9tIGZvciByZXByb2R1Y2liaWxpdHlcbiAgICBsZXQgc2VlZCA9IDQyO1xuICAgIGNvbnN0IHJhbmQgPSAoKSA9PiB7XG4gICAgICBzZWVkID0gKHNlZWQgKiAxNjgwNyArIDApICUgMjE0NzQ4MzY0NztcbiAgICAgIHJldHVybiAoc2VlZCAtIDEpIC8gMjE0NzQ4MzY0NjtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gTWF0aC5mbG9vcihyYW5kKCkgKiBPUFRJT05TX1BFUl9ST1cpO1xuICAgICAgICBwYXRoLnB1c2goYHIke3J9LW9wdCR7b3B0aW9uSWR4fWApO1xuICAgICAgfVxuICAgICAgdGltZWxpbmVzLnB1c2goe1xuICAgICAgICB1c2VySWQ6IGBtb2NrLXVzZXItJHtpfWAsXG4gICAgICAgIHBhdGg6IHBhdGggYXMgT3B0aW9uSWRbXSxcbiAgICAgICAgZmlnVHJlZVJlc3BvbnNlOiAnJyxcbiAgICAgICAgaGFybW9uaWNHcm91cDogJ0EnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lbGluZXM7XG4gIH0sIFtyb3dzLmxlbmd0aF0pO1xuXG4gIC8vIEFjY3VtdWxhdGVkIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgZmluYWxlXG4gIGNvbnN0IFtyZXZlYWxlZFRpbWVsaW5lcywgc2V0UmV2ZWFsZWRUaW1lbGluZXNdID0gdXNlU3RhdGU8RmluYWxlVGltZWxpbmVbXT4oW10pO1xuXG4gIC8vIFVzZSBwcm92aWRlZCB0aW1lbGluZXMsIG9yIG1vY2sgdGltZWxpbmVzIGZvciB0ZXN0aW5nIHdoZW4gaW4gZmluYWxlXG4gIGNvbnN0IGVmZmVjdGl2ZVRpbWVsaW5lcyA9IGF1ZGllbmNlVGltZWxpbmVzID8/IChzaG93UGhhc2UgPT09ICdmaW5hbGUnID8gbW9ja1RpbWVsaW5lcyA6IFtdKTtcblxuICAvLyBHZW5lcmF0ZSBzdGFibGUgZGVsdGEgaml0dGVyXG4gIGNvbnN0IGRlbHRhSml0dGVyID0gdXNlTWVtbygoKSA9PiBnZW5lcmF0ZURlbHRhSml0dGVyKDEyMywgcm93cy5sZW5ndGgpLCBbcm93cy5sZW5ndGhdKTtcblxuICAvLyBMYXlvdXQgY29uZmlndXJhdGlvblxuICBjb25zdCBsYXlvdXRDb25maWc6IExheW91dENvbmZpZyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHdpZHRoOiBTVkdfV0lEVEgsXG4gICAgICBoZWlnaHQ6IFNWR19IRUlHSFQsXG4gICAgICByb3dzOiByb3dzLmxlbmd0aCxcbiAgICAgIG9wdGlvbnM6IE9QVElPTlNfUEVSX1JPVyxcbiAgICB9KSxcbiAgICBbcm93cy5sZW5ndGhdXG4gICk7XG5cbiAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBlbnRlcmluZyBmaW5hbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvd1BoYXNlID09PSAnZmluYWxlJyAmJiBsYXlvdXRNb2RlICE9PSAndHJlZScpIHtcbiAgICAgIHNldExheW91dE1vZGUoJ3RyYW5zaXRpb25pbmcnKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCBhbmltYXRlID0gKG5vdzogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIFRSQU5TSVRJT05fRFVSQVRJT05fTVMsIDEpO1xuICAgICAgICBjb25zdCBlYXNlZCA9IGVhc2VJbk91dEN1YmljKHByb2dyZXNzKTtcbiAgICAgICAgc2V0TGF5b3V0UHJvZ3Jlc3MoZWFzZWQpO1xuXG4gICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TGF5b3V0TW9kZSgndHJlZScpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfSBlbHNlIGlmIChzaG93UGhhc2UgPT09ICdydW5uaW5nJyAmJiBsYXlvdXRNb2RlID09PSAndHJlZScpIHtcbiAgICAgIC8vIFJlc2V0IHRvIGdyaWQgKGluc3RhbnQpIGlmIHJldHVybmluZyB0byBydW5uaW5nXG4gICAgICBzZXRMYXlvdXRNb2RlKCdncmlkJyk7XG4gICAgICBzZXRMYXlvdXRQcm9ncmVzcygwKTtcbiAgICAgIHNldFJldmVhbGVkVGltZWxpbmVzKFtdKTtcbiAgICB9XG4gIH0sIFtzaG93UGhhc2UsIGxheW91dE1vZGVdKTtcblxuICAvLyBBY2N1bXVsYXRlIHJldmVhbGVkIHRpbWVsaW5lcyBkdXJpbmcgZmluYWxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY3VycmVudEZpbmFsZVRpbWVsaW5lICYmXG4gICAgICAhcmV2ZWFsZWRUaW1lbGluZXMuZmluZCgodCkgPT4gdC51c2VySWQgPT09IGN1cnJlbnRGaW5hbGVUaW1lbGluZS51c2VySWQpXG4gICAgKSB7XG4gICAgICBzZXRSZXZlYWxlZFRpbWVsaW5lcygocHJldikgPT4gWy4uLnByZXYsIGN1cnJlbnRGaW5hbGVUaW1lbGluZV0pO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRGaW5hbGVUaW1lbGluZSwgcmV2ZWFsZWRUaW1lbGluZXNdKTtcblxuICAvLyBQb3NpdGlvbiBmdW5jdGlvbiBiYXNlZCBvbiBsYXlvdXQgbW9kZVxuICBjb25zdCBnZXRQb3NpdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3c6IG51bWJlciwgb3B0aW9uOiBudW1iZXIpOiBQb2ludCA9PiB7XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ2dyaWQnIHx8IGxheW91dFByb2dyZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBncmlkUG9zaXRpb24ocm93LCBvcHRpb24sIGxheW91dENvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ3RyZWUnIHx8IGxheW91dFByb2dyZXNzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBkZWx0YVBvc2l0aW9uKHJvdywgb3B0aW9uLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWRQb3NpdGlvbihyb3csIG9wdGlvbiwgbGF5b3V0Q29uZmlnLCBsYXlvdXRQcm9ncmVzcywgZGVsdGFKaXR0ZXIpO1xuICAgIH0sXG4gICAgW2xheW91dE1vZGUsIGxheW91dFByb2dyZXNzLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyXVxuICApO1xuXG4gIC8vIEJ1aWxkIGZ1bGwgcGF0aCBzdHJpbmdzIGZvciBzbW9vdGggQ2F0bXVsbC1Sb20gY3VydmVzXG4gIGNvbnN0IGZhY3Rpb25QYXRoU3RyaW5nID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBhdGhzLmZhY3Rpb25QYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIGNvbnN0IHBvaW50cyA9IHBhdGhzLmZhY3Rpb25QYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gcGFyc2VPcHRpb25JbmRleChvcHRpb25JZCk7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24ocm93SWR4LCBvcHRpb25JZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYXRtdWxsUm9tUGF0aChwb2ludHMpO1xuICB9LCBbcGF0aHMuZmFjdGlvblBhdGgsIGdldFBvc2l0aW9uXSk7XG5cbiAgY29uc3QgcG9wdWxhclBhdGhTdHJpbmcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGF0aHMucG9wdWxhclBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgcG9pbnRzID0gcGF0aHMucG9wdWxhclBhdGgubWFwKChvcHRpb25JZCwgcm93SWR4KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihyb3dJZHgsIG9wdGlvbklkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhdG11bGxSb21QYXRoKHBvaW50cyk7XG4gIH0sIFtwYXRocy5wb3B1bGFyUGF0aCwgZ2V0UG9zaXRpb25dKTtcblxuICAvLyBCdWlsZCBhdWRpZW5jZSB0aW1lbGluZSBwYXRoIHN0cmluZ3NcbiAgY29uc3QgYXVkaWVuY2VQYXRoU3RyaW5ncyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBlZmZlY3RpdmVUaW1lbGluZXMubWFwKCh0aW1lbGluZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aW1lbGluZS5wYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHJvd0lkeCwgb3B0aW9uSWR4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkOiB0aW1lbGluZS51c2VySWQsXG4gICAgICAgIHBhdGg6IGNhdG11bGxSb21QYXRoKHBvaW50cyksXG4gICAgICAgIC8vIERldGVybWluZSBmYWN0aW9uIGZyb20gdXNlcklkIC0gZm9yIG5vdyB1c2UgbW9kdWxvIGFzIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIHVzZXIgZGF0YVxuICAgICAgICBmYWN0aW9uSW5kZXg6IGlkeCAlIDQsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbZWZmZWN0aXZlVGltZWxpbmVzLCBnZXRQb3NpdGlvbl0pO1xuXG4gIGNvbnN0IGlzVHJlZU1vZGUgPSBsYXlvdXRNb2RlID09PSAndHJlZScgfHwgbGF5b3V0UHJvZ3Jlc3MgPiAwO1xuICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBsYXlvdXRNb2RlID09PSAndHJhbnNpdGlvbmluZyc7XG4gIGNvbnN0IGhhc0F1ZGllbmNlUGF0aHMgPSBlZmZlY3RpdmVUaW1lbGluZXMubGVuZ3RoID4gMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgPHN2Z1xuICAgICAgICBzdHlsZT17c3R5bGVzLnN2Z31cbiAgICAgICAgdmlld0JveD17YDAgMCAke1NWR19XSURUSH0gJHtTVkdfSEVJR0hUfWB9XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgID5cbiAgICAgICAgey8qIEF1ZGllbmNlIHRpbWVsaW5lIHBhdGhzIChmaW5hbGUgLSBpbmRpdmlkdWFsX3RpbWVsaW5lcyBwaGFzZSkgKi99XG4gICAgICAgIHtmaW5hbGVQaGFzZSA9PT0gJ2luZGl2aWR1YWxfdGltZWxpbmVzJyAmJlxuICAgICAgICAgIGF1ZGllbmNlUGF0aFN0cmluZ3MubWFwKChhcCwgaWR4KSA9PiAoXG4gICAgICAgICAgICA8QW5pbWF0ZWRQYXRoXG4gICAgICAgICAgICAgIGtleT17YXAudXNlcklkfVxuICAgICAgICAgICAgICBwYXRoPXthcC5wYXRofVxuICAgICAgICAgICAgICBjb2xvcj17ZmFjdGlvbkNvbG9yc1thcC5mYWN0aW9uSW5kZXhdIHx8IEZBQ1RJT05fQ09MT1JTWzBdfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICBkZWxheT17aWR4ICogMTAwfVxuICAgICAgICAgICAgICBkdXJhdGlvbj17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG5cbiAgICAgICAgey8qIFBvcHVsYXIgcGF0aCAoZ2hvc3QvZGFzaGVkKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e3BvcHVsYXJQYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiIzY2NlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezN9XG4gICAgICAgICAgZGFzaEFycmF5PVwiOCA0XCJcbiAgICAgICAgICBvcGFjaXR5PXtoYXNBdWRpZW5jZVBhdGhzID8gMC4yIDogMC41fVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5wb3B1bGFyUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEZhY3Rpb24gcGF0aCAoc29saWQvd2lubmVyKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e2ZhY3Rpb25QYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiI2ZmZlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezR9XG4gICAgICAgICAgb3BhY2l0eT17aGFzQXVkaWVuY2VQYXRocyA/IDAuMTUgOiAxfVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5mYWN0aW9uUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIE9wdGlvbiBub2RlcyAqL31cbiAgICAgICAge3Jvd3MubWFwKChyb3cpID0+XG4gICAgICAgICAgcm93Lm9wdGlvbnMubWFwKChvcHRpb24sIG9wdElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCBvcHRJZHgpO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IHJvdy5waGFzZSAhPT0gJ3BlbmRpbmcnIHx8IHJvdy5pbmRleCA8PSBjdXJyZW50Um93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBpc0NvbW1pdHRlZCA9IHJvdy5jb21taXR0ZWRPcHRpb24gPT09IG9wdGlvbi5pZDtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5GYWN0aW9uUGF0aCA9IHBhdGhzLmZhY3Rpb25QYXRoLmluY2x1ZGVzKG9wdGlvbi5pZCk7XG4gICAgICAgICAgICBjb25zdCBpc1dpbm5lciA9IHZpc2libGUgJiYgKGlzQ29tbWl0dGVkIHx8IGlzSW5GYWN0aW9uUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSByb3cuaW5kZXggPT09IGN1cnJlbnRSb3dJbmRleCAmJiByb3cucGhhc2UgIT09ICdwZW5kaW5nJztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGcga2V5PXtvcHRpb24uaWR9PlxuICAgICAgICAgICAgICAgIHsvKiBXaW5uZXIgZ2xvdyByaW5nICovfVxuICAgICAgICAgICAgICAgIHtpc1dpbm5lciAmJiAoXG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICAgIGN4PXtwb3MueH1cbiAgICAgICAgICAgICAgICAgICAgY3k9e3Bvcy55fVxuICAgICAgICAgICAgICAgICAgICByPXtXSU5ORVJfUkFESVVTICsgNn1cbiAgICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCIjZmZmXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9ezAuMTJ9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ2N4IDEuNXMgZWFzZS1pbi1vdXQsIGN5IDEuNXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHsvKiBDdXJyZW50IHJvdyBnbG93ICovfVxuICAgICAgICAgICAgICAgIHtpc0N1cnJlbnQgJiYgIWlzV2lubmVyICYmIChcbiAgICAgICAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgY3g9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICAgIHI9e0RPVF9SQURJVVMgKyA4fVxuICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM0YWRlODBcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17MC40fVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB7LyogTWFpbiBub2RlIGNpcmNsZSAqL31cbiAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICBjeD17cG9zLnh9XG4gICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICByPXtpc1dpbm5lciA/IFdJTk5FUl9SQURJVVMgOiBET1RfUkFESVVTfVxuICAgICAgICAgICAgICAgICAgZmlsbD17IXZpc2libGUgPyAnIzFhMWEyMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjM2EzYTQ0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17IXZpc2libGUgPyAnIzJhMmEzMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjNGE0YTU0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXt2aXNpYmxlID8gMS41IDogMC41fVxuICAgICAgICAgICAgICAgICAgb3BhY2l0eT17dmlzaWJsZSA/IDEgOiAwLjM1fVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgPyAnciAwLjRzIGVhc2UsIGZpbGwgMC40cyBlYXNlLCBvcGFjaXR5IDAuNHMgZWFzZSdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0LCByIDAuNHMgZWFzZSwgZmlsbCAwLjRzIGVhc2UsIG9wYWNpdHkgMC40cyBlYXNlJyxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7LyogT3B0aW9uIGxhYmVsICovfVxuICAgICAgICAgICAgICAgIHt2aXNpYmxlICYmIChcbiAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHg9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICB5PXtwb3MueSArIDF9XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXs5fVxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXs3MDB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGw9e2lzV2lubmVyID8gJyMwYjBiMGYnIDogJyM2NjYnfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICd4IDEuNXMgZWFzZS1pbi1vdXQsIHkgMS41cyBlYXNlLWluLW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7U3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIG9wdElkeCl9XG4gICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApfVxuXG4gICAgICAgIHsvKiBSb3cgbGFiZWxzICovfVxuICAgICAgICB7cm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHZpc2libGUgPSByb3cucGhhc2UgIT09ICdwZW5kaW5nJyB8fCByb3cuaW5kZXggPD0gY3VycmVudFJvd0luZGV4O1xuICAgICAgICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjb25zdCBsZWZ0UG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCAwKTtcbiAgICAgICAgICBjb25zdCBsYWJlbFggPSBpc1RyZWVNb2RlXG4gICAgICAgICAgICA/IE1hdGgubWluKGxlZnRQb3MueCwgZ2V0UG9zaXRpb24ocm93LmluZGV4LCBPUFRJT05TX1BFUl9ST1cgLSAxKS54KSAtIDMwXG4gICAgICAgICAgICA6IGxlZnRQb3MueCAtIDQwO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgIGtleT17YGxhYmVsLSR7cm93LmluZGV4fWB9XG4gICAgICAgICAgICAgIHg9e2xhYmVsWH1cbiAgICAgICAgICAgICAgeT17bGVmdFBvcy55ICsgMX1cbiAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cImVuZFwiXG4gICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9ezEwfVxuICAgICAgICAgICAgICBmaWxsPVwiIzQ0NFwiXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ3ggMS41cyBlYXNlLWluLW91dCwgeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3Jvdy5sYWJlbCB8fCBgUiR7cm93LmluZGV4ICsgMX1gfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICk7XG59KTtcblxuLy8g4pSA4pSA4pSAIFN0eWxlcyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuY29uc3Qgc3R5bGVzID0ge1xuICBjb250YWluZXI6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLFxuXG4gIHN2Zzoge1xuICAgIHdpZHRoOiAnOTAlJyxcbiAgICBoZWlnaHQ6ICc5MCUnLFxuICAgIG1heFdpZHRoOiBTVkdfV0lEVEgsXG4gICAgbWF4SGVpZ2h0OiBTVkdfSEVJR0hULFxuICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsXG59O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwibWVtbyIsIlNWR19XSURUSCIsIlNWR19IRUlHSFQiLCJPUFRJT05TX1BFUl9ST1ciLCJGQUNUSU9OX0NPTE9SUyIsIkRPVF9SQURJVVMiLCJXSU5ORVJfUkFESVVTIiwiR1JJRF9DT0xfU1BBQ0lORyIsIkdSSURfUk9XX1NQQUNJTkciLCJUUkFOU0lUSU9OX0RVUkFUSU9OX01TIiwiZ3JpZFBvc2l0aW9uIiwicm93Iiwib3B0aW9uIiwiY29uZmlnIiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsImRlbHRhUG9zaXRpb24iLCJqaXR0ZXIiLCJ5MCIsInlUb3AiLCJ0b3RhbEgiLCJ0Iiwicm93cyIsInNwcmVhZCIsIk1hdGgiLCJwb3ciLCJvZmZzZXRzIiwia2V5IiwiZHgiLCJkeSIsImludGVycG9sYXRlZFBvc2l0aW9uIiwicHJvZ3Jlc3MiLCJncmlkUG9zIiwiZGVsdGFQb3MiLCJnZW5lcmF0ZURlbHRhSml0dGVyIiwic2VlZCIsIm51bVJvd3MiLCJzIiwicmFuZCIsIm9wdCIsIm1hZ25pdHVkZSIsImRpc3RhbmNlIiwicDEiLCJwMiIsInNxcnQiLCJjYXRtdWxsUm9tUGF0aCIsInBvaW50cyIsImFscGhhIiwibGVuZ3RoIiwiZXh0ZW5kZWQiLCJwYXRoIiwiaSIsInAwIiwicDMiLCJkMSIsImQyIiwiZDMiLCJkMWEiLCJkMmEiLCJkM2EiLCJkMWEyIiwiZDJhMiIsImQzYTIiLCJkZW5vbTEiLCJjcDF4IiwiY3AxeSIsImRlbm9tMiIsImNwMngiLCJjcDJ5IiwicGFyc2VPcHRpb25JbmRleCIsIm9wdGlvbklkIiwibWF0Y2giLCJwYXJzZUludCIsImVhc2VJbk91dEN1YmljIiwiQW5pbWF0ZWRQYXRoIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsImRhc2hBcnJheSIsIm9wYWNpdHkiLCJkZWxheSIsImR1cmF0aW9uIiwicGF0aFJlZiIsInBhdGhMZW5ndGgiLCJzZXRQYXRoTGVuZ3RoIiwiYW5pbWF0ZWRMZW5ndGhSZWYiLCJhbmltU3RhdGUiLCJzZXRBbmltU3RhdGUiLCJ0YXJnZXRPZmZzZXQiLCJzZXRUYXJnZXRPZmZzZXQiLCJjdXJyZW50IiwidG90YWxMZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsIm5ld1NlZ21lbnRMZW5ndGgiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRhc2hPZmZzZXQiLCJlZmZlY3RpdmVEYXNoQXJyYXkiLCJyZWYiLCJkIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJTb25nVHJlZSIsInBhdGhzIiwiY3VycmVudFJvd0luZGV4Iiwic2hvd1BoYXNlIiwiZmluYWxlUGhhc2UiLCJjdXJyZW50RmluYWxlVGltZWxpbmUiLCJmYWN0aW9uQ29sb3JzIiwiYXVkaWVuY2VUaW1lbGluZXMiLCJkaXYiLCJzdHlsZXMiLCJjb250YWluZXIiLCJmb250U2l6ZSIsInRleHRBbGlnbiIsImxheW91dE1vZGUiLCJzZXRMYXlvdXRNb2RlIiwibGF5b3V0UHJvZ3Jlc3MiLCJzZXRMYXlvdXRQcm9ncmVzcyIsIm1vY2tUaW1lbGluZXMiLCJ0aW1lbGluZXMiLCJyIiwib3B0aW9uSWR4IiwiZmxvb3IiLCJwdXNoIiwidXNlcklkIiwiZmlnVHJlZVJlc3BvbnNlIiwiaGFybW9uaWNHcm91cCIsInJldmVhbGVkVGltZWxpbmVzIiwic2V0UmV2ZWFsZWRUaW1lbGluZXMiLCJlZmZlY3RpdmVUaW1lbGluZXMiLCJkZWx0YUppdHRlciIsImxheW91dENvbmZpZyIsIm9wdGlvbnMiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImFuaW1hdGUiLCJlbGFwc2VkIiwibWluIiwiZWFzZWQiLCJmaW5kIiwicHJldiIsImdldFBvc2l0aW9uIiwiZmFjdGlvblBhdGhTdHJpbmciLCJmYWN0aW9uUGF0aCIsIm1hcCIsInJvd0lkeCIsInBvcHVsYXJQYXRoU3RyaW5nIiwicG9wdWxhclBhdGgiLCJhdWRpZW5jZVBhdGhTdHJpbmdzIiwidGltZWxpbmUiLCJpZHgiLCJmYWN0aW9uSW5kZXgiLCJpc1RyZWVNb2RlIiwiaXNUcmFuc2l0aW9uaW5nIiwiaGFzQXVkaWVuY2VQYXRocyIsInN2ZyIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiYXAiLCJvcHRJZHgiLCJwb3MiLCJpbmRleCIsInZpc2libGUiLCJwaGFzZSIsImlzQ29tbWl0dGVkIiwiY29tbWl0dGVkT3B0aW9uIiwiaWQiLCJpc0luRmFjdGlvblBhdGgiLCJpbmNsdWRlcyIsImlzV2lubmVyIiwiaXNDdXJyZW50IiwiZyIsImNpcmNsZSIsImN4IiwiY3kiLCJ0ZXh0IiwidGV4dEFuY2hvciIsImRvbWluYW50QmFzZWxpbmUiLCJmb250V2VpZ2h0IiwicG9pbnRlckV2ZW50cyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImxlZnRQb3MiLCJsYWJlbFgiLCJsYWJlbCIsInBvc2l0aW9uIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIm92ZXJmbG93IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SongTree.tsx\n"));

/***/ })

});