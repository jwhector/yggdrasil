"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projector/page",{

/***/ "(app-pages-browser)/./components/SongTree.tsx":
/*!*********************************!*\
  !*** ./components/SongTree.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SongTree: function() { return /* binding */ SongTree; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * SongTree Component\n *\n * Core visualization showing the song construction as a tree of options.\n * Displays dual paths: faction path (solid) and popular path (ghost/dashed).\n *\n * Features:\n * - Bottom-to-top row progression (row 0 at bottom)\n * - Grid layout during 'running' phase\n * - River delta layout during 'finale' phase (tight root, organically spreading tributaries)\n * - Smooth Catmull-Rom curved paths\n * - Animated individual audience paths during finale\n */ /* __next_internal_client_entry_do_not_use__ SongTree auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// ─── Constants ──────────────────────────────────────────────────────────────\nconst SVG_WIDTH = 800;\nconst SVG_HEIGHT = 700;\nconst OPTIONS_PER_ROW = 4;\nconst FACTION_COLORS = [\n    \"#e05c5c\",\n    \"#5cb8e0\",\n    \"#5ce08a\",\n    \"#e0c55c\"\n];\nconst DOT_RADIUS = 8;\nconst WINNER_RADIUS = 11;\n// Grid layout spacing\nconst GRID_COL_SPACING = 70;\nconst GRID_ROW_SPACING = 56;\n// Transition duration\nconst TRANSITION_DURATION_MS = 1500;\n// ─── Layout Functions ───────────────────────────────────────────────────────\n/**\n * Grid position - linear layout used during 'running' phase\n * Bottom-to-top: row 0 at bottom, higher rows at top\n */ function gridPosition(row, option, config) {\n    const { width, height } = config;\n    const x = width / 2 - GRID_COL_SPACING * 1.5 + option * GRID_COL_SPACING;\n    const y = height - 70 - row * GRID_ROW_SPACING;\n    return {\n        x,\n        y\n    };\n}\n/**\n * Delta position - river delta / tributary layout used during 'finale' phase\n * Single source at bottom, paths branch outward with organic spread.\n * Jitter increases with row depth for natural asymmetry.\n */ function deltaPosition(row, option, config, jitter) {\n    const { width, height } = config;\n    // Bottom-to-top Y positioning with increasing spacing toward the top\n    const y0 = height - 60;\n    const yTop = 60;\n    const totalH = y0 - yTop;\n    // Use a slight power curve so upper rows get more room to spread\n    const t = row / (config.rows - 1); // 0 at bottom, 1 at top\n    let y = y0 - t * totalH;\n    // Spread increases as a power curve — tight at the root, wide at the tips\n    const spread = 20 + Math.pow(row, 1.8) * 14;\n    // 4 options evenly distributed across the spread\n    const offsets = [\n        -1.5,\n        -0.5,\n        0.5,\n        1.5\n    ];\n    let x = width / 2 + offsets[option] * spread;\n    // Apply stable jitter — increases with row for organic feel\n    const key = \"\".concat(row, \"-\").concat(option);\n    if (jitter[key]) {\n        x += jitter[key].dx;\n        y += jitter[key].dy;\n    }\n    return {\n        x,\n        y\n    };\n}\n/**\n * Interpolate between grid and tree positions\n */ function interpolatedPosition(row, option, config, progress, jitter) {\n    const gridPos = gridPosition(row, option, config);\n    const deltaPos = deltaPosition(row, option, config, jitter);\n    return {\n        x: gridPos.x + (deltaPos.x - gridPos.x) * progress,\n        y: gridPos.y + (deltaPos.y - gridPos.y) * progress\n    };\n}\n/**\n * Generate stable jitter for delta layout.\n * Jitter magnitude increases with row index — tight at root, loose at tips.\n * Row 0 gets no jitter (common source), higher rows spread organically.\n */ function generateDeltaJitter(seed, numRows) {\n    let s = seed;\n    const rand = ()=>{\n        s = (s * 16807 + 0) % 2147483647;\n        return (s - 1) / 2147483646;\n    };\n    const jitter = {};\n    for(let row = 0; row < numRows; row++){\n        for(let opt = 0; opt < OPTIONS_PER_ROW; opt++){\n            // Scale jitter: none at row 0, increasing toward top rows\n            const magnitude = row <= 1 ? 0 : Math.pow(row - 1, 1.2) * 4;\n            jitter[\"\".concat(row, \"-\").concat(opt)] = {\n                dx: (rand() - 0.5) * magnitude,\n                dy: (rand() - 0.5) * magnitude * 0.6\n            };\n        }\n    }\n    return jitter;\n}\n// ─── Curve Generation ───────────────────────────────────────────────────────\n/**\n * Calculate distance between two points\n */ function distance(p1, p2) {\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n}\n/**\n * Generate a Catmull-Rom spline path string\n * Alpha 0.5 = centripetal (avoids cusps and self-intersections)\n */ function catmullRomPath(points) {\n    let alpha = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n    if (points.length === 0) return \"\";\n    if (points.length === 1) return \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    if (points.length === 2) {\n        return \"M \".concat(points[0].x, \",\").concat(points[0].y, \" L \").concat(points[1].x, \",\").concat(points[1].y);\n    }\n    // Duplicate first and last points for end tangents\n    const extended = [\n        points[0],\n        ...points,\n        points[points.length - 1]\n    ];\n    let path = \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    for(let i = 1; i < extended.length - 2; i++){\n        const p0 = extended[i - 1];\n        const p1 = extended[i];\n        const p2 = extended[i + 1];\n        const p3 = extended[i + 2];\n        const d1 = distance(p0, p1);\n        const d2 = distance(p1, p2);\n        const d3 = distance(p2, p3);\n        // Avoid division by zero\n        if (d1 < 0.001 || d2 < 0.001 || d3 < 0.001) {\n            path += \" L \".concat(p2.x, \",\").concat(p2.y);\n            continue;\n        }\n        const d1a = Math.pow(d1, alpha);\n        const d2a = Math.pow(d2, alpha);\n        const d3a = Math.pow(d3, alpha);\n        const d1a2 = Math.pow(d1, 2 * alpha);\n        const d2a2 = Math.pow(d2, 2 * alpha);\n        const d3a2 = Math.pow(d3, 2 * alpha);\n        // Control point 1\n        const denom1 = 3 * d1a * (d1a + d2a);\n        const cp1x = denom1 !== 0 ? (d1a2 * p2.x - d2a2 * p0.x + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.x) / denom1 : (p1.x + p2.x) / 2;\n        const cp1y = denom1 !== 0 ? (d1a2 * p2.y - d2a2 * p0.y + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.y) / denom1 : (p1.y + p2.y) / 2;\n        // Control point 2\n        const denom2 = 3 * d3a * (d3a + d2a);\n        const cp2x = denom2 !== 0 ? (d3a2 * p1.x - d2a2 * p3.x + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.x) / denom2 : (p1.x + p2.x) / 2;\n        const cp2y = denom2 !== 0 ? (d3a2 * p1.y - d2a2 * p3.y + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.y) / denom2 : (p1.y + p2.y) / 2;\n        path += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p2.x, \",\").concat(p2.y);\n    }\n    return path;\n}\n// ─── Utility Functions ──────────────────────────────────────────────────────\n/**\n * Parse option index from optionId (e.g., \"r0-opt2\" → 2)\n */ function parseOptionIndex(optionId) {\n    const match = optionId.match(/opt(\\d+)$/);\n    return match ? parseInt(match[1], 10) : 0;\n}\n/**\n * Easing function for smooth animation\n */ function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n}\nconst AnimatedPath = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_s(function AnimatedPath(param) {\n    let { path, color, strokeWidth, dashArray, opacity = 1, delay = 0, duration = 1200 } = param;\n    _s();\n    const pathRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [pathLength, setPathLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Track the animated portion: starts at 0, grows as we animate\n    const [animatedLength, setAnimatedLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Track whether we're currently in an animation\n    const [isAnimating, setIsAnimating] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Measure path length when path changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!pathRef.current || !path) return;\n        const totalLength = pathRef.current.getTotalLength();\n        setPathLength(totalLength);\n    }, [\n        path\n    ]);\n    // Trigger animation when path grows beyond what we've animated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (pathLength === 0 || pathLength <= animatedLength) return;\n        // New segment detected - animate it\n        setIsAnimating(false);\n        // Use requestAnimationFrame to ensure the non-animated state renders first\n        const raf = requestAnimationFrame(()=>{\n            const timer = setTimeout(()=>{\n                setIsAnimating(true);\n                // After animation completes, update animatedLength\n                setTimeout(()=>{\n                    setAnimatedLength(pathLength);\n                }, duration);\n            }, delay);\n            // Store timer for cleanup\n            raf.timer = timer;\n        });\n        return ()=>{\n            cancelAnimationFrame(raf);\n            if (raf.timer) clearTimeout(raf.timer);\n        };\n    }, [\n        pathLength,\n        animatedLength,\n        delay,\n        duration\n    ]);\n    if (!path) return null;\n    // Calculate how much is \"new\" (not yet animated)\n    const newSegmentLength = pathLength - animatedLength;\n    // For solid lines: use path length as single dash\n    // For dashed lines: we need a compound pattern that allows offset animation\n    const effectiveDashArray = dashArray ? \"\".concat(pathLength, \" \").concat(pathLength) // Compound pattern for dashed lines\n     : \"\".concat(pathLength);\n    // Offset hides the new segment until animation reveals it\n    const dashOffset = isAnimating ? 0 : newSegmentLength;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n        ref: pathRef,\n        d: path,\n        fill: \"none\",\n        stroke: color,\n        strokeWidth: strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        strokeDasharray: effectiveDashArray,\n        strokeDashoffset: dashOffset,\n        opacity: opacity,\n        style: {\n            transition: isAnimating ? \"stroke-dashoffset \".concat(duration, \"ms ease-in-out, opacity 1s ease\") : \"none\"\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 344,\n        columnNumber: 5\n    }, this);\n}, \"YOAtSnsS1vd79Csx8nnLZXHf1ks=\"));\n_c = AnimatedPath;\n// ─── Main Component ─────────────────────────────────────────────────────────\nconst SongTree = /*#__PURE__*/ _s1((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c1 = _s1(function SongTree(param) {\n    let { rows, paths, currentRowIndex, showPhase, finalePhase, currentFinaleTimeline, factionColors = FACTION_COLORS, audienceTimelines } = param;\n    _s1();\n    // Defensive check: ensure rows exist\n    if (!rows || rows.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: styles.container,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"#999\",\n                    fontSize: \"1.5rem\",\n                    textAlign: \"center\"\n                },\n                children: \"Loading song tree...\"\n            }, void 0, false, {\n                fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                lineNumber: 380,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 379,\n            columnNumber: 7\n        }, this);\n    }\n    // Layout state - always start in grid mode, let useEffect handle transition\n    const [layoutMode, setLayoutMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"grid\");\n    const [layoutProgress, setLayoutProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Generate mock audience timelines for testing (30 users with random paths)\n    const mockTimelines = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const timelines = [];\n        const numRows = rows.length;\n        // Seeded random for reproducibility\n        let seed = 42;\n        const rand = ()=>{\n            seed = (seed * 16807 + 0) % 2147483647;\n            return (seed - 1) / 2147483646;\n        };\n        for(let i = 0; i < 30; i++){\n            const path = [];\n            for(let r = 0; r < numRows; r++){\n                const optionIdx = Math.floor(rand() * OPTIONS_PER_ROW);\n                path.push(\"r\".concat(r, \"-opt\").concat(optionIdx));\n            }\n            timelines.push({\n                userId: \"mock-user-\".concat(i),\n                path: path,\n                figTreeResponse: \"\",\n                harmonicGroup: \"A\"\n            });\n        }\n        return timelines;\n    }, [\n        rows.length\n    ]);\n    // Accumulated audience timelines for finale\n    const [revealedTimelines, setRevealedTimelines] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Use provided timelines, or mock timelines for testing when in finale\n    const effectiveTimelines = audienceTimelines !== null && audienceTimelines !== void 0 ? audienceTimelines : showPhase === \"finale\" ? mockTimelines : [];\n    // Generate stable delta jitter\n    const deltaJitter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>generateDeltaJitter(123, rows.length), [\n        rows.length\n    ]);\n    // Layout configuration\n    const layoutConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            width: SVG_WIDTH,\n            height: SVG_HEIGHT,\n            rows: rows.length,\n            options: OPTIONS_PER_ROW\n        }), [\n        rows.length\n    ]);\n    // Transition animation when entering finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showPhase === \"finale\" && layoutMode !== \"tree\") {\n            setLayoutMode(\"transitioning\");\n            const startTime = performance.now();\n            const animate = (now)=>{\n                const elapsed = now - startTime;\n                const progress = Math.min(elapsed / TRANSITION_DURATION_MS, 1);\n                const eased = easeInOutCubic(progress);\n                setLayoutProgress(eased);\n                if (progress < 1) {\n                    requestAnimationFrame(animate);\n                } else {\n                    setLayoutMode(\"tree\");\n                }\n            };\n            requestAnimationFrame(animate);\n        } else if (showPhase === \"running\" && layoutMode === \"tree\") {\n            // Reset to grid (instant) if returning to running\n            setLayoutMode(\"grid\");\n            setLayoutProgress(0);\n            setRevealedTimelines([]);\n        }\n    }, [\n        showPhase,\n        layoutMode\n    ]);\n    // Accumulate revealed timelines during finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentFinaleTimeline && !revealedTimelines.find((t)=>t.userId === currentFinaleTimeline.userId)) {\n            setRevealedTimelines((prev)=>[\n                    ...prev,\n                    currentFinaleTimeline\n                ]);\n        }\n    }, [\n        currentFinaleTimeline,\n        revealedTimelines\n    ]);\n    // Position function based on layout mode\n    const getPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((row, option)=>{\n        if (layoutMode === \"grid\" || layoutProgress === 0) {\n            return gridPosition(row, option, layoutConfig);\n        }\n        if (layoutMode === \"tree\" || layoutProgress === 1) {\n            return deltaPosition(row, option, layoutConfig, deltaJitter);\n        }\n        return interpolatedPosition(row, option, layoutConfig, layoutProgress, deltaJitter);\n    }, [\n        layoutMode,\n        layoutProgress,\n        layoutConfig,\n        deltaJitter\n    ]);\n    // Build full path strings for smooth Catmull-Rom curves\n    const factionPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.factionPath.length === 0) return \"\";\n        const points = paths.factionPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.factionPath,\n        getPosition\n    ]);\n    const popularPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.popularPath.length === 0) return \"\";\n        const points = paths.popularPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.popularPath,\n        getPosition\n    ]);\n    // Build audience timeline path strings\n    const audiencePathStrings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return effectiveTimelines.map((timeline, idx)=>{\n            const points = timeline.path.map((optionId, rowIdx)=>{\n                const optionIdx = parseOptionIndex(optionId);\n                return getPosition(rowIdx, optionIdx);\n            });\n            return {\n                userId: timeline.userId,\n                path: catmullRomPath(points),\n                // Determine faction from userId - for now use modulo as placeholder\n                // In production, this would come from user data\n                factionIndex: idx % 4\n            };\n        });\n    }, [\n        effectiveTimelines,\n        getPosition\n    ]);\n    const isTreeMode = layoutMode === \"tree\" || layoutProgress > 0;\n    const isTransitioning = layoutMode === \"transitioning\";\n    const hasAudiencePaths = effectiveTimelines.length > 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: styles.container,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n            style: styles.svg,\n            viewBox: \"0 0 \".concat(SVG_WIDTH, \" \").concat(SVG_HEIGHT),\n            preserveAspectRatio: \"xMidYMid meet\",\n            children: [\n                finalePhase === \"individual_timelines\" && audiencePathStrings.map((ap, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                        path: ap.path,\n                        color: factionColors[ap.factionIndex] || FACTION_COLORS[0],\n                        strokeWidth: 2,\n                        opacity: 0.5,\n                        delay: idx * 100,\n                        duration: 1000\n                    }, ap.userId, false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 541,\n                        columnNumber: 13\n                    }, this)),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: popularPathString,\n                    color: \"#666\",\n                    strokeWidth: 3,\n                    dashArray: \"8 4\",\n                    opacity: hasAudiencePaths ? 0.2 : 0.5,\n                    delay: 0,\n                    duration: paths.popularPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 553,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: factionPathString,\n                    color: \"#fff\",\n                    strokeWidth: 4,\n                    opacity: hasAudiencePaths ? 0.15 : 1,\n                    delay: 0,\n                    duration: paths.factionPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 564,\n                    columnNumber: 9\n                }, this),\n                rows.map((row)=>row.options.map((option, optIdx)=>{\n                        const pos = getPosition(row.index, optIdx);\n                        const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                        const isCommitted = row.committedOption === option.id;\n                        const isInFactionPath = paths.factionPath.includes(option.id);\n                        const isWinner = visible && (isCommitted || isInFactionPath);\n                        const isCurrent = row.index === currentRowIndex && row.phase !== \"pending\";\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: WINNER_RADIUS + 6,\n                                    fill: \"none\",\n                                    stroke: \"#fff\",\n                                    strokeWidth: 1,\n                                    opacity: 0.12,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 587,\n                                    columnNumber: 19\n                                }, this),\n                                isCurrent && !isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: DOT_RADIUS + 8,\n                                    fill: \"none\",\n                                    stroke: \"#4ade80\",\n                                    strokeWidth: 2,\n                                    opacity: 0.4,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 602,\n                                    columnNumber: 19\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: isWinner ? WINNER_RADIUS : DOT_RADIUS,\n                                    fill: !visible ? \"#1a1a22\" : isWinner ? \"#fff\" : \"#3a3a44\",\n                                    stroke: !visible ? \"#2a2a32\" : isWinner ? \"#fff\" : \"#4a4a54\",\n                                    strokeWidth: visible ? 1.5 : 0.5,\n                                    opacity: visible ? 1 : 0.35,\n                                    style: {\n                                        transition: isTransitioning ? \"r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out, r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 616,\n                                    columnNumber: 17\n                                }, this),\n                                visible && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: pos.x,\n                                    y: pos.y + 1,\n                                    textAnchor: \"middle\",\n                                    dominantBaseline: \"central\",\n                                    fontSize: 9,\n                                    fontWeight: 700,\n                                    fill: isWinner ? \"#0b0b0f\" : \"#666\",\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\",\n                                        pointerEvents: \"none\"\n                                    },\n                                    children: String.fromCharCode(65 + optIdx)\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 632,\n                                    columnNumber: 19\n                                }, this)\n                            ]\n                        }, option.id, true, {\n                            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                            lineNumber: 584,\n                            columnNumber: 15\n                        }, this);\n                    })),\n                rows.map((row)=>{\n                    const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                    if (!visible) return null;\n                    const leftPos = getPosition(row.index, 0);\n                    const labelX = isTreeMode ? Math.min(leftPos.x, getPosition(row.index, OPTIONS_PER_ROW - 1).x) - 30 : leftPos.x - 40;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                        x: labelX,\n                        y: leftPos.y + 1,\n                        textAnchor: \"end\",\n                        dominantBaseline: \"central\",\n                        fontSize: 10,\n                        fill: \"#444\",\n                        style: {\n                            transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\"\n                        },\n                        children: row.label || \"R\".concat(row.index + 1)\n                    }, \"label-\".concat(row.index), false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 664,\n                        columnNumber: 13\n                    }, this);\n                })\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 533,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 532,\n        columnNumber: 5\n    }, this);\n}, \"guEy+xxSdFmLvFrSDXYY5p7qbhE=\")), \"guEy+xxSdFmLvFrSDXYY5p7qbhE=\");\n_c2 = SongTree;\n// ─── Styles ─────────────────────────────────────────────────────────────────\nconst styles = {\n    container: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        overflow: \"hidden\"\n    },\n    svg: {\n        width: \"90%\",\n        height: \"90%\",\n        maxWidth: SVG_WIDTH,\n        maxHeight: SVG_HEIGHT\n    }\n};\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AnimatedPath\");\n$RefreshReg$(_c1, \"SongTree$memo\");\n$RefreshReg$(_c2, \"SongTree\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU29uZ1RyZWUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUM7O0FBSStFO0FBOENoRiwrRUFBK0U7QUFFL0UsTUFBTU0sWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGtCQUFrQjtBQUV4QixNQUFNQyxpQkFBaUI7SUFBQztJQUFXO0lBQVc7SUFBVztDQUFVO0FBQ25FLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCO0FBRXRCLHNCQUFzQjtBQUN0QixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsbUJBQW1CO0FBRXpCLHNCQUFzQjtBQUN0QixNQUFNQyx5QkFBeUI7QUFFL0IsK0VBQStFO0FBRS9FOzs7Q0FHQyxHQUNELFNBQVNDLGFBQWFDLEdBQVcsRUFBRUMsTUFBYyxFQUFFQyxNQUFvQjtJQUNyRSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO0lBQzFCLE1BQU1HLElBQUlGLFFBQVEsSUFBSVAsbUJBQW1CLE1BQU1LLFNBQVNMO0lBQ3hELE1BQU1VLElBQUlGLFNBQVMsS0FBS0osTUFBTUg7SUFDOUIsT0FBTztRQUFFUTtRQUFHQztJQUFFO0FBQ2hCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLGNBQ1BQLEdBQVcsRUFDWEMsTUFBYyxFQUNkQyxNQUFvQixFQUNwQk0sTUFBa0Q7SUFFbEQsTUFBTSxFQUFFTCxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUUxQixxRUFBcUU7SUFDckUsTUFBTU8sS0FBS0wsU0FBUztJQUNwQixNQUFNTSxPQUFPO0lBQ2IsTUFBTUMsU0FBU0YsS0FBS0M7SUFFcEIsaUVBQWlFO0lBQ2pFLE1BQU1FLElBQUlaLE1BQU9FLENBQUFBLE9BQU9XLElBQUksR0FBRyxJQUFJLHdCQUF3QjtJQUMzRCxJQUFJUCxJQUFJRyxLQUFLRyxJQUFJRDtJQUVqQiwwRUFBMEU7SUFDMUUsTUFBTUcsU0FBUyxL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QUNSdUwsU0FBUztRQUNUQyxZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsVUFBVTtJQUNaO0lBRUFsQyxLQUFLO1FBQ0h6SixPQUFPO1FBQ1BDLFFBQVE7UUFDUjJMLFVBQVV6TTtRQUNWME0sV0FBV3pNO0lBQ2I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL1NvbmdUcmVlLnRzeD9iOWUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU29uZ1RyZWUgQ29tcG9uZW50XG4gKlxuICogQ29yZSB2aXN1YWxpemF0aW9uIHNob3dpbmcgdGhlIHNvbmcgY29uc3RydWN0aW9uIGFzIGEgdHJlZSBvZiBvcHRpb25zLlxuICogRGlzcGxheXMgZHVhbCBwYXRoczogZmFjdGlvbiBwYXRoIChzb2xpZCkgYW5kIHBvcHVsYXIgcGF0aCAoZ2hvc3QvZGFzaGVkKS5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gQm90dG9tLXRvLXRvcCByb3cgcHJvZ3Jlc3Npb24gKHJvdyAwIGF0IGJvdHRvbSlcbiAqIC0gR3JpZCBsYXlvdXQgZHVyaW5nICdydW5uaW5nJyBwaGFzZVxuICogLSBSaXZlciBkZWx0YSBsYXlvdXQgZHVyaW5nICdmaW5hbGUnIHBoYXNlICh0aWdodCByb290LCBvcmdhbmljYWxseSBzcHJlYWRpbmcgdHJpYnV0YXJpZXMpXG4gKiAtIFNtb290aCBDYXRtdWxsLVJvbSBjdXJ2ZWQgcGF0aHNcbiAqIC0gQW5pbWF0ZWQgaW5kaXZpZHVhbCBhdWRpZW5jZSBwYXRocyBkdXJpbmcgZmluYWxlXG4gKi9cblxuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBEdWFsUGF0aHMsIE9wdGlvbklkLCBSb3dQaGFzZSwgU2hvd0NvbmZpZywgU2hvd1BoYXNlLCBGaW5hbGVUaW1lbGluZSB9IGZyb20gJ0AvY29uZHVjdG9yL3R5cGVzJztcblxuLy8g4pSA4pSA4pSAIFR5cGVzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG5leHBvcnQgaW50ZXJmYWNlIFNvbmdUcmVlUHJvcHMge1xuICByb3dzOiBBcnJheTx7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBvcHRpb25zOiBBcnJheTx7XG4gICAgICBpZDogT3B0aW9uSWQ7XG4gICAgICBpbmRleDogbnVtYmVyO1xuICAgICAgYXVkaW9SZWY6IHN0cmluZztcbiAgICAgIGhhcm1vbmljR3JvdXA/OiBzdHJpbmc7XG4gICAgfT47XG4gICAgcGhhc2U6IFJvd1BoYXNlO1xuICAgIGNvbW1pdHRlZE9wdGlvbjogT3B0aW9uSWQgfCBudWxsO1xuICAgIGN1cnJlbnRBdWRpdGlvbkluZGV4OiBudW1iZXIgfCBudWxsO1xuICAgIGF0dGVtcHRzOiBudW1iZXI7XG4gIH0+O1xuICBwYXRoczogRHVhbFBhdGhzO1xuICBjdXJyZW50Um93SW5kZXg6IG51bWJlcjtcbiAgY29uZmlnPzogU2hvd0NvbmZpZztcbiAgLy8gTmV3IHByb3BzIGZvciBmaW5hbGUgc3VwcG9ydFxuICBzaG93UGhhc2U6IFNob3dQaGFzZTtcbiAgZmluYWxlUGhhc2U/OiAncG9wdWxhcl9zb25nJyB8ICdpbmRpdmlkdWFsX3RpbWVsaW5lcycgfCBudWxsO1xuICBjdXJyZW50RmluYWxlVGltZWxpbmU/OiBGaW5hbGVUaW1lbGluZSB8IG51bGw7XG4gIGZhY3Rpb25Db2xvcnM/OiBzdHJpbmdbXTtcbiAgYXVkaWVuY2VUaW1lbGluZXM/OiBGaW5hbGVUaW1lbGluZVtdO1xufVxuXG5pbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIExheW91dENvbmZpZyB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICByb3dzOiBudW1iZXI7XG4gIG9wdGlvbnM6IG51bWJlcjtcbn1cblxudHlwZSBMYXlvdXRNb2RlID0gJ2dyaWQnIHwgJ3RyZWUnIHwgJ3RyYW5zaXRpb25pbmcnO1xuXG4vLyDilIDilIDilIAgQ29uc3RhbnRzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG5jb25zdCBTVkdfV0lEVEggPSA4MDA7XG5jb25zdCBTVkdfSEVJR0hUID0gNzAwO1xuY29uc3QgT1BUSU9OU19QRVJfUk9XID0gNDtcblxuY29uc3QgRkFDVElPTl9DT0xPUlMgPSBbJyNlMDVjNWMnLCAnIzVjYjhlMCcsICcjNWNlMDhhJywgJyNlMGM1NWMnXTtcbmNvbnN0IERPVF9SQURJVVMgPSA4O1xuY29uc3QgV0lOTkVSX1JBRElVUyA9IDExO1xuXG4vLyBHcmlkIGxheW91dCBzcGFjaW5nXG5jb25zdCBHUklEX0NPTF9TUEFDSU5HID0gNzA7XG5jb25zdCBHUklEX1JPV19TUEFDSU5HID0gNTY7XG5cbi8vIFRyYW5zaXRpb24gZHVyYXRpb25cbmNvbnN0IFRSQU5TSVRJT05fRFVSQVRJT05fTVMgPSAxNTAwO1xuXG4vLyDilIDilIDilIAgTGF5b3V0IEZ1bmN0aW9ucyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuLyoqXG4gKiBHcmlkIHBvc2l0aW9uIC0gbGluZWFyIGxheW91dCB1c2VkIGR1cmluZyAncnVubmluZycgcGhhc2VcbiAqIEJvdHRvbS10by10b3A6IHJvdyAwIGF0IGJvdHRvbSwgaGlnaGVyIHJvd3MgYXQgdG9wXG4gKi9cbmZ1bmN0aW9uIGdyaWRQb3NpdGlvbihyb3c6IG51bWJlciwgb3B0aW9uOiBudW1iZXIsIGNvbmZpZzogTGF5b3V0Q29uZmlnKTogUG9pbnQge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbmZpZztcbiAgY29uc3QgeCA9IHdpZHRoIC8gMiAtIEdSSURfQ09MX1NQQUNJTkcgKiAxLjUgKyBvcHRpb24gKiBHUklEX0NPTF9TUEFDSU5HO1xuICBjb25zdCB5ID0gaGVpZ2h0IC0gNzAgLSByb3cgKiBHUklEX1JPV19TUEFDSU5HO1xuICByZXR1cm4geyB4LCB5IH07XG59XG5cbi8qKlxuICogRGVsdGEgcG9zaXRpb24gLSByaXZlciBkZWx0YSAvIHRyaWJ1dGFyeSBsYXlvdXQgdXNlZCBkdXJpbmcgJ2ZpbmFsZScgcGhhc2VcbiAqIFNpbmdsZSBzb3VyY2UgYXQgYm90dG9tLCBwYXRocyBicmFuY2ggb3V0d2FyZCB3aXRoIG9yZ2FuaWMgc3ByZWFkLlxuICogSml0dGVyIGluY3JlYXNlcyB3aXRoIHJvdyBkZXB0aCBmb3IgbmF0dXJhbCBhc3ltbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIGRlbHRhUG9zaXRpb24oXG4gIHJvdzogbnVtYmVyLFxuICBvcHRpb246IG51bWJlcixcbiAgY29uZmlnOiBMYXlvdXRDb25maWcsXG4gIGppdHRlcjogUmVjb3JkPHN0cmluZywgeyBkeDogbnVtYmVyOyBkeTogbnVtYmVyIH0+XG4pOiBQb2ludCB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY29uZmlnO1xuXG4gIC8vIEJvdHRvbS10by10b3AgWSBwb3NpdGlvbmluZyB3aXRoIGluY3JlYXNpbmcgc3BhY2luZyB0b3dhcmQgdGhlIHRvcFxuICBjb25zdCB5MCA9IGhlaWdodCAtIDYwO1xuICBjb25zdCB5VG9wID0gNjA7XG4gIGNvbnN0IHRvdGFsSCA9IHkwIC0geVRvcDtcblxuICAvLyBVc2UgYSBzbGlnaHQgcG93ZXIgY3VydmUgc28gdXBwZXIgcm93cyBnZXQgbW9yZSByb29tIHRvIHNwcmVhZFxuICBjb25zdCB0ID0gcm93IC8gKGNvbmZpZy5yb3dzIC0gMSk7IC8vIDAgYXQgYm90dG9tLCAxIGF0IHRvcFxuICBsZXQgeSA9IHkwIC0gdCAqIHRvdGFsSDtcblxuICAvLyBTcHJlYWQgaW5jcmVhc2VzIGFzIGEgcG93ZXIgY3VydmUg4oCUIHRpZ2h0IGF0IHRoZSByb290LCB3aWRlIGF0IHRoZSB0aXBzXG4gIGNvbnN0IHNwcmVhZCA9IDIwICsgTWF0aC5wb3cocm93LCAxLjgpICogMTQ7XG5cbiAgLy8gNCBvcHRpb25zIGV2ZW5seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIHNwcmVhZFxuICBjb25zdCBvZmZzZXRzID0gWy0xLjUsIC0wLjUsIDAuNSwgMS41XTtcbiAgbGV0IHggPSB3aWR0aCAvIDIgKyBvZmZzZXRzW29wdGlvbl0gKiBzcHJlYWQ7XG5cbiAgLy8gQXBwbHkgc3RhYmxlIGppdHRlciDigJQgaW5jcmVhc2VzIHdpdGggcm93IGZvciBvcmdhbmljIGZlZWxcbiAgY29uc3Qga2V5ID0gYCR7cm93fS0ke29wdGlvbn1gO1xuICBpZiAoaml0dGVyW2tleV0pIHtcbiAgICB4ICs9IGppdHRlcltrZXldLmR4O1xuICAgIHkgKz0gaml0dGVyW2tleV0uZHk7XG4gIH1cblxuICByZXR1cm4geyB4LCB5IH07XG59XG5cbi8qKlxuICogSW50ZXJwb2xhdGUgYmV0d2VlbiBncmlkIGFuZCB0cmVlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZWRQb3NpdGlvbihcbiAgcm93OiBudW1iZXIsXG4gIG9wdGlvbjogbnVtYmVyLFxuICBjb25maWc6IExheW91dENvbmZpZyxcbiAgcHJvZ3Jlc3M6IG51bWJlcixcbiAgaml0dGVyOiBSZWNvcmQ8c3RyaW5nLCB7IGR4OiBudW1iZXI7IGR5OiBudW1iZXIgfT5cbik6IFBvaW50IHtcbiAgY29uc3QgZ3JpZFBvcyA9IGdyaWRQb3NpdGlvbihyb3csIG9wdGlvbiwgY29uZmlnKTtcbiAgY29uc3QgZGVsdGFQb3MgPSBkZWx0YVBvc2l0aW9uKHJvdywgb3B0aW9uLCBjb25maWcsIGppdHRlcik7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBncmlkUG9zLnggKyAoZGVsdGFQb3MueCAtIGdyaWRQb3MueCkgKiBwcm9ncmVzcyxcbiAgICB5OiBncmlkUG9zLnkgKyAoZGVsdGFQb3MueSAtIGdyaWRQb3MueSkgKiBwcm9ncmVzcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzdGFibGUgaml0dGVyIGZvciBkZWx0YSBsYXlvdXQuXG4gKiBKaXR0ZXIgbWFnbml0dWRlIGluY3JlYXNlcyB3aXRoIHJvdyBpbmRleCDigJQgdGlnaHQgYXQgcm9vdCwgbG9vc2UgYXQgdGlwcy5cbiAqIFJvdyAwIGdldHMgbm8gaml0dGVyIChjb21tb24gc291cmNlKSwgaGlnaGVyIHJvd3Mgc3ByZWFkIG9yZ2FuaWNhbGx5LlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZURlbHRhSml0dGVyKHNlZWQ6IG51bWJlciwgbnVtUm93czogbnVtYmVyKTogUmVjb3JkPHN0cmluZywgeyBkeDogbnVtYmVyOyBkeTogbnVtYmVyIH0+IHtcbiAgbGV0IHMgPSBzZWVkO1xuICBjb25zdCByYW5kID0gKCkgPT4ge1xuICAgIHMgPSAocyAqIDE2ODA3ICsgMCkgJSAyMTQ3NDgzNjQ3O1xuICAgIHJldHVybiAocyAtIDEpIC8gMjE0NzQ4MzY0NjtcbiAgfTtcblxuICBjb25zdCBqaXR0ZXI6IFJlY29yZDxzdHJpbmcsIHsgZHg6IG51bWJlcjsgZHk6IG51bWJlciB9PiA9IHt9O1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBudW1Sb3dzOyByb3crKykge1xuICAgIGZvciAobGV0IG9wdCA9IDA7IG9wdCA8IE9QVElPTlNfUEVSX1JPVzsgb3B0KyspIHtcbiAgICAgIC8vIFNjYWxlIGppdHRlcjogbm9uZSBhdCByb3cgMCwgaW5jcmVhc2luZyB0b3dhcmQgdG9wIHJvd3NcbiAgICAgIGNvbnN0IG1hZ25pdHVkZSA9IHJvdyA8PSAxID8gMCA6IE1hdGgucG93KHJvdyAtIDEsIDEuMikgKiA0O1xuICAgICAgaml0dGVyW2Ake3Jvd30tJHtvcHR9YF0gPSB7XG4gICAgICAgIGR4OiAocmFuZCgpIC0gMC41KSAqIG1hZ25pdHVkZSxcbiAgICAgICAgZHk6IChyYW5kKCkgLSAwLjUpICogbWFnbml0dWRlICogMC42LFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGppdHRlcjtcbn1cblxuLy8g4pSA4pSA4pSAIEN1cnZlIEdlbmVyYXRpb24g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZShwMTogUG9pbnQsIHAyOiBQb2ludCk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqKiAyICsgKHAyLnkgLSBwMS55KSAqKiAyKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIENhdG11bGwtUm9tIHNwbGluZSBwYXRoIHN0cmluZ1xuICogQWxwaGEgMC41ID0gY2VudHJpcGV0YWwgKGF2b2lkcyBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zKVxuICovXG5mdW5jdGlvbiBjYXRtdWxsUm9tUGF0aChwb2ludHM6IFBvaW50W10sIGFscGhhOiBudW1iZXIgPSAwLjUpOiBzdHJpbmcge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGBNICR7cG9pbnRzWzBdLnh9LCR7cG9pbnRzWzBdLnl9YDtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gYE0gJHtwb2ludHNbMF0ueH0sJHtwb2ludHNbMF0ueX0gTCAke3BvaW50c1sxXS54fSwke3BvaW50c1sxXS55fWA7XG4gIH1cblxuICAvLyBEdXBsaWNhdGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGZvciBlbmQgdGFuZ2VudHNcbiAgY29uc3QgZXh0ZW5kZWQgPSBbcG9pbnRzWzBdLCAuLi5wb2ludHMsIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV1dO1xuXG4gIGxldCBwYXRoID0gYE0gJHtwb2ludHNbMF0ueH0sJHtwb2ludHNbMF0ueX1gO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kZWQubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgY29uc3QgcDAgPSBleHRlbmRlZFtpIC0gMV07XG4gICAgY29uc3QgcDEgPSBleHRlbmRlZFtpXTtcbiAgICBjb25zdCBwMiA9IGV4dGVuZGVkW2kgKyAxXTtcbiAgICBjb25zdCBwMyA9IGV4dGVuZGVkW2kgKyAyXTtcblxuICAgIGNvbnN0IGQxID0gZGlzdGFuY2UocDAsIHAxKTtcbiAgICBjb25zdCBkMiA9IGRpc3RhbmNlKHAxLCBwMik7XG4gICAgY29uc3QgZDMgPSBkaXN0YW5jZShwMiwgcDMpO1xuXG4gICAgLy8gQXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgIGlmIChkMSA8IDAuMDAxIHx8IGQyIDwgMC4wMDEgfHwgZDMgPCAwLjAwMSkge1xuICAgICAgcGF0aCArPSBgIEwgJHtwMi54fSwke3AyLnl9YDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGQxYSA9IE1hdGgucG93KGQxLCBhbHBoYSk7XG4gICAgY29uc3QgZDJhID0gTWF0aC5wb3coZDIsIGFscGhhKTtcbiAgICBjb25zdCBkM2EgPSBNYXRoLnBvdyhkMywgYWxwaGEpO1xuXG4gICAgY29uc3QgZDFhMiA9IE1hdGgucG93KGQxLCAyICogYWxwaGEpO1xuICAgIGNvbnN0IGQyYTIgPSBNYXRoLnBvdyhkMiwgMiAqIGFscGhhKTtcbiAgICBjb25zdCBkM2EyID0gTWF0aC5wb3coZDMsIDIgKiBhbHBoYSk7XG5cbiAgICAvLyBDb250cm9sIHBvaW50IDFcbiAgICBjb25zdCBkZW5vbTEgPSAzICogZDFhICogKGQxYSArIGQyYSk7XG4gICAgY29uc3QgY3AxeCA9IGRlbm9tMSAhPT0gMFxuICAgICAgPyAoZDFhMiAqIHAyLnggLSBkMmEyICogcDAueCArICgyICogZDFhMiArIDMgKiBkMWEgKiBkMmEgKyBkMmEyKSAqIHAxLngpIC8gZGVub20xXG4gICAgICA6IChwMS54ICsgcDIueCkgLyAyO1xuICAgIGNvbnN0IGNwMXkgPSBkZW5vbTEgIT09IDBcbiAgICAgID8gKGQxYTIgKiBwMi55IC0gZDJhMiAqIHAwLnkgKyAoMiAqIGQxYTIgKyAzICogZDFhICogZDJhICsgZDJhMikgKiBwMS55KSAvIGRlbm9tMVxuICAgICAgOiAocDEueSArIHAyLnkpIC8gMjtcblxuICAgIC8vIENvbnRyb2wgcG9pbnQgMlxuICAgIGNvbnN0IGRlbm9tMiA9IDMgKiBkM2EgKiAoZDNhICsgZDJhKTtcbiAgICBjb25zdCBjcDJ4ID0gZGVub20yICE9PSAwXG4gICAgICA/IChkM2EyICogcDEueCAtIGQyYTIgKiBwMy54ICsgKDIgKiBkM2EyICsgMyAqIGQzYSAqIGQyYSArIGQyYTIpICogcDIueCkgLyBkZW5vbTJcbiAgICAgIDogKHAxLnggKyBwMi54KSAvIDI7XG4gICAgY29uc3QgY3AyeSA9IGRlbm9tMiAhPT0gMFxuICAgICAgPyAoZDNhMiAqIHAxLnkgLSBkMmEyICogcDMueSArICgyICogZDNhMiArIDMgKiBkM2EgKiBkMmEgKyBkMmEyKSAqIHAyLnkpIC8gZGVub20yXG4gICAgICA6IChwMS55ICsgcDIueSkgLyAyO1xuXG4gICAgcGF0aCArPSBgIEMgJHtjcDF4fSwke2NwMXl9ICR7Y3AyeH0sJHtjcDJ5fSAke3AyLnh9LCR7cDIueX1gO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8vIOKUgOKUgOKUgCBVdGlsaXR5IEZ1bmN0aW9ucyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuLyoqXG4gKiBQYXJzZSBvcHRpb24gaW5kZXggZnJvbSBvcHRpb25JZCAoZS5nLiwgXCJyMC1vcHQyXCIg4oaSIDIpXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3B0aW9uSW5kZXgob3B0aW9uSWQ6IE9wdGlvbklkKTogbnVtYmVyIHtcbiAgY29uc3QgbWF0Y2ggPSBvcHRpb25JZC5tYXRjaCgvb3B0KFxcZCspJC8pO1xuICByZXR1cm4gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMDtcbn1cblxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gZm9yIHNtb290aCBhbmltYXRpb25cbiAqL1xuZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogMSAtIE1hdGgucG93KC0yICogdCArIDIsIDMpIC8gMjtcbn1cblxuLy8g4pSA4pSA4pSAIEFuaW1hdGVkUGF0aCBDb21wb25lbnQg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbmludGVyZmFjZSBBbmltYXRlZFBhdGhQcm9wcyB7XG4gIHBhdGg6IHN0cmluZztcbiAgY29sb3I6IHN0cmluZztcbiAgc3Ryb2tlV2lkdGg6IG51bWJlcjtcbiAgZGFzaEFycmF5Pzogc3RyaW5nO1xuICBvcGFjaXR5PzogbnVtYmVyO1xuICBkZWxheT86IG51bWJlcjtcbiAgZHVyYXRpb24/OiBudW1iZXI7XG59XG5cbmNvbnN0IEFuaW1hdGVkUGF0aCA9IG1lbW8oZnVuY3Rpb24gQW5pbWF0ZWRQYXRoKHtcbiAgcGF0aCxcbiAgY29sb3IsXG4gIHN0cm9rZVdpZHRoLFxuICBkYXNoQXJyYXksXG4gIG9wYWNpdHkgPSAxLFxuICBkZWxheSA9IDAsXG4gIGR1cmF0aW9uID0gMTIwMCxcbn06IEFuaW1hdGVkUGF0aFByb3BzKSB7XG4gIGNvbnN0IHBhdGhSZWYgPSB1c2VSZWY8U1ZHUGF0aEVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBbcGF0aExlbmd0aCwgc2V0UGF0aExlbmd0aF0gPSB1c2VTdGF0ZSgwKTtcbiAgLy8gVHJhY2sgdGhlIGFuaW1hdGVkIHBvcnRpb246IHN0YXJ0cyBhdCAwLCBncm93cyBhcyB3ZSBhbmltYXRlXG4gIGNvbnN0IFthbmltYXRlZExlbmd0aCwgc2V0QW5pbWF0ZWRMZW5ndGhdID0gdXNlU3RhdGUoMCk7XG4gIC8vIFRyYWNrIHdoZXRoZXIgd2UncmUgY3VycmVudGx5IGluIGFuIGFuaW1hdGlvblxuICBjb25zdCBbaXNBbmltYXRpbmcsIHNldElzQW5pbWF0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBNZWFzdXJlIHBhdGggbGVuZ3RoIHdoZW4gcGF0aCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwYXRoUmVmLmN1cnJlbnQgfHwgIXBhdGgpIHJldHVybjtcbiAgICBjb25zdCB0b3RhbExlbmd0aCA9IHBhdGhSZWYuY3VycmVudC5nZXRUb3RhbExlbmd0aCgpO1xuICAgIHNldFBhdGhMZW5ndGgodG90YWxMZW5ndGgpO1xuICB9LCBbcGF0aF0pO1xuXG4gIC8vIFRyaWdnZXIgYW5pbWF0aW9uIHdoZW4gcGF0aCBncm93cyBiZXlvbmQgd2hhdCB3ZSd2ZSBhbmltYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwYXRoTGVuZ3RoID09PSAwIHx8IHBhdGhMZW5ndGggPD0gYW5pbWF0ZWRMZW5ndGgpIHJldHVybjtcblxuICAgIC8vIE5ldyBzZWdtZW50IGRldGVjdGVkIC0gYW5pbWF0ZSBpdFxuICAgIHNldElzQW5pbWF0aW5nKGZhbHNlKTtcblxuICAgIC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gZW5zdXJlIHRoZSBub24tYW5pbWF0ZWQgc3RhdGUgcmVuZGVycyBmaXJzdFxuICAgIGNvbnN0IHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRJc0FuaW1hdGluZyh0cnVlKTtcbiAgICAgICAgLy8gQWZ0ZXIgYW5pbWF0aW9uIGNvbXBsZXRlcywgdXBkYXRlIGFuaW1hdGVkTGVuZ3RoXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldEFuaW1hdGVkTGVuZ3RoKHBhdGhMZW5ndGgpO1xuICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICB9LCBkZWxheSk7XG5cbiAgICAgIC8vIFN0b3JlIHRpbWVyIGZvciBjbGVhbnVwXG4gICAgICAocmFmIGFzIGFueSkudGltZXIgPSB0aW1lcjtcbiAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgaWYgKChyYWYgYXMgYW55KS50aW1lcikgY2xlYXJUaW1lb3V0KChyYWYgYXMgYW55KS50aW1lcik7XG4gICAgfTtcbiAgfSwgW3BhdGhMZW5ndGgsIGFuaW1hdGVkTGVuZ3RoLCBkZWxheSwgZHVyYXRpb25dKTtcblxuICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gIC8vIENhbGN1bGF0ZSBob3cgbXVjaCBpcyBcIm5ld1wiIChub3QgeWV0IGFuaW1hdGVkKVxuICBjb25zdCBuZXdTZWdtZW50TGVuZ3RoID0gcGF0aExlbmd0aCAtIGFuaW1hdGVkTGVuZ3RoO1xuXG4gIC8vIEZvciBzb2xpZCBsaW5lczogdXNlIHBhdGggbGVuZ3RoIGFzIHNpbmdsZSBkYXNoXG4gIC8vIEZvciBkYXNoZWQgbGluZXM6IHdlIG5lZWQgYSBjb21wb3VuZCBwYXR0ZXJuIHRoYXQgYWxsb3dzIG9mZnNldCBhbmltYXRpb25cbiAgY29uc3QgZWZmZWN0aXZlRGFzaEFycmF5ID0gZGFzaEFycmF5XG4gICAgPyBgJHtwYXRoTGVuZ3RofSAke3BhdGhMZW5ndGh9YCAvLyBDb21wb3VuZCBwYXR0ZXJuIGZvciBkYXNoZWQgbGluZXNcbiAgICA6IGAke3BhdGhMZW5ndGh9YDtcblxuICAvLyBPZmZzZXQgaGlkZXMgdGhlIG5ldyBzZWdtZW50IHVudGlsIGFuaW1hdGlvbiByZXZlYWxzIGl0XG4gIGNvbnN0IGRhc2hPZmZzZXQgPSBpc0FuaW1hdGluZyA/IDAgOiBuZXdTZWdtZW50TGVuZ3RoO1xuXG4gIHJldHVybiAoXG4gICAgPHBhdGhcbiAgICAgIHJlZj17cGF0aFJlZn1cbiAgICAgIGQ9e3BhdGh9XG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBzdHJva2U9e2NvbG9yfVxuICAgICAgc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofVxuICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgc3Ryb2tlRGFzaGFycmF5PXtlZmZlY3RpdmVEYXNoQXJyYXl9XG4gICAgICBzdHJva2VEYXNob2Zmc2V0PXtkYXNoT2Zmc2V0fVxuICAgICAgb3BhY2l0eT17b3BhY2l0eX1cbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHRyYW5zaXRpb246IGlzQW5pbWF0aW5nXG4gICAgICAgICAgPyBgc3Ryb2tlLWRhc2hvZmZzZXQgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dCwgb3BhY2l0eSAxcyBlYXNlYFxuICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG5cbi8vIOKUgOKUgOKUgCBNYWluIENvbXBvbmVudCDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZXhwb3J0IGNvbnN0IFNvbmdUcmVlID0gbWVtbyhmdW5jdGlvbiBTb25nVHJlZSh7XG4gIHJvd3MsXG4gIHBhdGhzLFxuICBjdXJyZW50Um93SW5kZXgsXG4gIHNob3dQaGFzZSxcbiAgZmluYWxlUGhhc2UsXG4gIGN1cnJlbnRGaW5hbGVUaW1lbGluZSxcbiAgZmFjdGlvbkNvbG9ycyA9IEZBQ1RJT05fQ09MT1JTLFxuICBhdWRpZW5jZVRpbWVsaW5lcyxcbn06IFNvbmdUcmVlUHJvcHMpIHtcbiAgLy8gRGVmZW5zaXZlIGNoZWNrOiBlbnN1cmUgcm93cyBleGlzdFxuICBpZiAoIXJvd3MgfHwgcm93cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6ICcjOTk5JywgZm9udFNpemU6ICcxLjVyZW0nLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxuICAgICAgICAgIExvYWRpbmcgc29uZyB0cmVlLi4uXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIExheW91dCBzdGF0ZSAtIGFsd2F5cyBzdGFydCBpbiBncmlkIG1vZGUsIGxldCB1c2VFZmZlY3QgaGFuZGxlIHRyYW5zaXRpb25cbiAgY29uc3QgW2xheW91dE1vZGUsIHNldExheW91dE1vZGVdID0gdXNlU3RhdGU8TGF5b3V0TW9kZT4oJ2dyaWQnKTtcbiAgY29uc3QgW2xheW91dFByb2dyZXNzLCBzZXRMYXlvdXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBHZW5lcmF0ZSBtb2NrIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgdGVzdGluZyAoMzAgdXNlcnMgd2l0aCByYW5kb20gcGF0aHMpXG4gIGNvbnN0IG1vY2tUaW1lbGluZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB0aW1lbGluZXM6IEZpbmFsZVRpbWVsaW5lW10gPSBbXTtcbiAgICBjb25zdCBudW1Sb3dzID0gcm93cy5sZW5ndGg7XG5cbiAgICAvLyBTZWVkZWQgcmFuZG9tIGZvciByZXByb2R1Y2liaWxpdHlcbiAgICBsZXQgc2VlZCA9IDQyO1xuICAgIGNvbnN0IHJhbmQgPSAoKSA9PiB7XG4gICAgICBzZWVkID0gKHNlZWQgKiAxNjgwNyArIDApICUgMjE0NzQ4MzY0NztcbiAgICAgIHJldHVybiAoc2VlZCAtIDEpIC8gMjE0NzQ4MzY0NjtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gTWF0aC5mbG9vcihyYW5kKCkgKiBPUFRJT05TX1BFUl9ST1cpO1xuICAgICAgICBwYXRoLnB1c2goYHIke3J9LW9wdCR7b3B0aW9uSWR4fWApO1xuICAgICAgfVxuICAgICAgdGltZWxpbmVzLnB1c2goe1xuICAgICAgICB1c2VySWQ6IGBtb2NrLXVzZXItJHtpfWAsXG4gICAgICAgIHBhdGg6IHBhdGggYXMgT3B0aW9uSWRbXSxcbiAgICAgICAgZmlnVHJlZVJlc3BvbnNlOiAnJyxcbiAgICAgICAgaGFybW9uaWNHcm91cDogJ0EnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lbGluZXM7XG4gIH0sIFtyb3dzLmxlbmd0aF0pO1xuXG4gIC8vIEFjY3VtdWxhdGVkIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgZmluYWxlXG4gIGNvbnN0IFtyZXZlYWxlZFRpbWVsaW5lcywgc2V0UmV2ZWFsZWRUaW1lbGluZXNdID0gdXNlU3RhdGU8RmluYWxlVGltZWxpbmVbXT4oW10pO1xuXG4gIC8vIFVzZSBwcm92aWRlZCB0aW1lbGluZXMsIG9yIG1vY2sgdGltZWxpbmVzIGZvciB0ZXN0aW5nIHdoZW4gaW4gZmluYWxlXG4gIGNvbnN0IGVmZmVjdGl2ZVRpbWVsaW5lcyA9IGF1ZGllbmNlVGltZWxpbmVzID8/IChzaG93UGhhc2UgPT09ICdmaW5hbGUnID8gbW9ja1RpbWVsaW5lcyA6IFtdKTtcblxuICAvLyBHZW5lcmF0ZSBzdGFibGUgZGVsdGEgaml0dGVyXG4gIGNvbnN0IGRlbHRhSml0dGVyID0gdXNlTWVtbygoKSA9PiBnZW5lcmF0ZURlbHRhSml0dGVyKDEyMywgcm93cy5sZW5ndGgpLCBbcm93cy5sZW5ndGhdKTtcblxuICAvLyBMYXlvdXQgY29uZmlndXJhdGlvblxuICBjb25zdCBsYXlvdXRDb25maWc6IExheW91dENvbmZpZyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHdpZHRoOiBTVkdfV0lEVEgsXG4gICAgICBoZWlnaHQ6IFNWR19IRUlHSFQsXG4gICAgICByb3dzOiByb3dzLmxlbmd0aCxcbiAgICAgIG9wdGlvbnM6IE9QVElPTlNfUEVSX1JPVyxcbiAgICB9KSxcbiAgICBbcm93cy5sZW5ndGhdXG4gICk7XG5cbiAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBlbnRlcmluZyBmaW5hbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvd1BoYXNlID09PSAnZmluYWxlJyAmJiBsYXlvdXRNb2RlICE9PSAndHJlZScpIHtcbiAgICAgIHNldExheW91dE1vZGUoJ3RyYW5zaXRpb25pbmcnKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCBhbmltYXRlID0gKG5vdzogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIFRSQU5TSVRJT05fRFVSQVRJT05fTVMsIDEpO1xuICAgICAgICBjb25zdCBlYXNlZCA9IGVhc2VJbk91dEN1YmljKHByb2dyZXNzKTtcbiAgICAgICAgc2V0TGF5b3V0UHJvZ3Jlc3MoZWFzZWQpO1xuXG4gICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TGF5b3V0TW9kZSgndHJlZScpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfSBlbHNlIGlmIChzaG93UGhhc2UgPT09ICdydW5uaW5nJyAmJiBsYXlvdXRNb2RlID09PSAndHJlZScpIHtcbiAgICAgIC8vIFJlc2V0IHRvIGdyaWQgKGluc3RhbnQpIGlmIHJldHVybmluZyB0byBydW5uaW5nXG4gICAgICBzZXRMYXlvdXRNb2RlKCdncmlkJyk7XG4gICAgICBzZXRMYXlvdXRQcm9ncmVzcygwKTtcbiAgICAgIHNldFJldmVhbGVkVGltZWxpbmVzKFtdKTtcbiAgICB9XG4gIH0sIFtzaG93UGhhc2UsIGxheW91dE1vZGVdKTtcblxuICAvLyBBY2N1bXVsYXRlIHJldmVhbGVkIHRpbWVsaW5lcyBkdXJpbmcgZmluYWxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY3VycmVudEZpbmFsZVRpbWVsaW5lICYmXG4gICAgICAhcmV2ZWFsZWRUaW1lbGluZXMuZmluZCgodCkgPT4gdC51c2VySWQgPT09IGN1cnJlbnRGaW5hbGVUaW1lbGluZS51c2VySWQpXG4gICAgKSB7XG4gICAgICBzZXRSZXZlYWxlZFRpbWVsaW5lcygocHJldikgPT4gWy4uLnByZXYsIGN1cnJlbnRGaW5hbGVUaW1lbGluZV0pO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRGaW5hbGVUaW1lbGluZSwgcmV2ZWFsZWRUaW1lbGluZXNdKTtcblxuICAvLyBQb3NpdGlvbiBmdW5jdGlvbiBiYXNlZCBvbiBsYXlvdXQgbW9kZVxuICBjb25zdCBnZXRQb3NpdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3c6IG51bWJlciwgb3B0aW9uOiBudW1iZXIpOiBQb2ludCA9PiB7XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ2dyaWQnIHx8IGxheW91dFByb2dyZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBncmlkUG9zaXRpb24ocm93LCBvcHRpb24sIGxheW91dENvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ3RyZWUnIHx8IGxheW91dFByb2dyZXNzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBkZWx0YVBvc2l0aW9uKHJvdywgb3B0aW9uLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWRQb3NpdGlvbihyb3csIG9wdGlvbiwgbGF5b3V0Q29uZmlnLCBsYXlvdXRQcm9ncmVzcywgZGVsdGFKaXR0ZXIpO1xuICAgIH0sXG4gICAgW2xheW91dE1vZGUsIGxheW91dFByb2dyZXNzLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyXVxuICApO1xuXG4gIC8vIEJ1aWxkIGZ1bGwgcGF0aCBzdHJpbmdzIGZvciBzbW9vdGggQ2F0bXVsbC1Sb20gY3VydmVzXG4gIGNvbnN0IGZhY3Rpb25QYXRoU3RyaW5nID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBhdGhzLmZhY3Rpb25QYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIGNvbnN0IHBvaW50cyA9IHBhdGhzLmZhY3Rpb25QYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gcGFyc2VPcHRpb25JbmRleChvcHRpb25JZCk7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24ocm93SWR4LCBvcHRpb25JZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYXRtdWxsUm9tUGF0aChwb2ludHMpO1xuICB9LCBbcGF0aHMuZmFjdGlvblBhdGgsIGdldFBvc2l0aW9uXSk7XG5cbiAgY29uc3QgcG9wdWxhclBhdGhTdHJpbmcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGF0aHMucG9wdWxhclBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgcG9pbnRzID0gcGF0aHMucG9wdWxhclBhdGgubWFwKChvcHRpb25JZCwgcm93SWR4KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihyb3dJZHgsIG9wdGlvbklkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhdG11bGxSb21QYXRoKHBvaW50cyk7XG4gIH0sIFtwYXRocy5wb3B1bGFyUGF0aCwgZ2V0UG9zaXRpb25dKTtcblxuICAvLyBCdWlsZCBhdWRpZW5jZSB0aW1lbGluZSBwYXRoIHN0cmluZ3NcbiAgY29uc3QgYXVkaWVuY2VQYXRoU3RyaW5ncyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBlZmZlY3RpdmVUaW1lbGluZXMubWFwKCh0aW1lbGluZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aW1lbGluZS5wYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHJvd0lkeCwgb3B0aW9uSWR4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkOiB0aW1lbGluZS51c2VySWQsXG4gICAgICAgIHBhdGg6IGNhdG11bGxSb21QYXRoKHBvaW50cyksXG4gICAgICAgIC8vIERldGVybWluZSBmYWN0aW9uIGZyb20gdXNlcklkIC0gZm9yIG5vdyB1c2UgbW9kdWxvIGFzIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIHVzZXIgZGF0YVxuICAgICAgICBmYWN0aW9uSW5kZXg6IGlkeCAlIDQsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbZWZmZWN0aXZlVGltZWxpbmVzLCBnZXRQb3NpdGlvbl0pO1xuXG4gIGNvbnN0IGlzVHJlZU1vZGUgPSBsYXlvdXRNb2RlID09PSAndHJlZScgfHwgbGF5b3V0UHJvZ3Jlc3MgPiAwO1xuICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBsYXlvdXRNb2RlID09PSAndHJhbnNpdGlvbmluZyc7XG4gIGNvbnN0IGhhc0F1ZGllbmNlUGF0aHMgPSBlZmZlY3RpdmVUaW1lbGluZXMubGVuZ3RoID4gMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgPHN2Z1xuICAgICAgICBzdHlsZT17c3R5bGVzLnN2Z31cbiAgICAgICAgdmlld0JveD17YDAgMCAke1NWR19XSURUSH0gJHtTVkdfSEVJR0hUfWB9XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgID5cbiAgICAgICAgey8qIEF1ZGllbmNlIHRpbWVsaW5lIHBhdGhzIChmaW5hbGUgLSBpbmRpdmlkdWFsX3RpbWVsaW5lcyBwaGFzZSkgKi99XG4gICAgICAgIHtmaW5hbGVQaGFzZSA9PT0gJ2luZGl2aWR1YWxfdGltZWxpbmVzJyAmJlxuICAgICAgICAgIGF1ZGllbmNlUGF0aFN0cmluZ3MubWFwKChhcCwgaWR4KSA9PiAoXG4gICAgICAgICAgICA8QW5pbWF0ZWRQYXRoXG4gICAgICAgICAgICAgIGtleT17YXAudXNlcklkfVxuICAgICAgICAgICAgICBwYXRoPXthcC5wYXRofVxuICAgICAgICAgICAgICBjb2xvcj17ZmFjdGlvbkNvbG9yc1thcC5mYWN0aW9uSW5kZXhdIHx8IEZBQ1RJT05fQ09MT1JTWzBdfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICBkZWxheT17aWR4ICogMTAwfVxuICAgICAgICAgICAgICBkdXJhdGlvbj17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG5cbiAgICAgICAgey8qIFBvcHVsYXIgcGF0aCAoZ2hvc3QvZGFzaGVkKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e3BvcHVsYXJQYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiIzY2NlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezN9XG4gICAgICAgICAgZGFzaEFycmF5PVwiOCA0XCJcbiAgICAgICAgICBvcGFjaXR5PXtoYXNBdWRpZW5jZVBhdGhzID8gMC4yIDogMC41fVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5wb3B1bGFyUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEZhY3Rpb24gcGF0aCAoc29saWQvd2lubmVyKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e2ZhY3Rpb25QYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiI2ZmZlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezR9XG4gICAgICAgICAgb3BhY2l0eT17aGFzQXVkaWVuY2VQYXRocyA/IDAuMTUgOiAxfVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5mYWN0aW9uUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIE9wdGlvbiBub2RlcyAqL31cbiAgICAgICAge3Jvd3MubWFwKChyb3cpID0+XG4gICAgICAgICAgcm93Lm9wdGlvbnMubWFwKChvcHRpb24sIG9wdElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCBvcHRJZHgpO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IHJvdy5waGFzZSAhPT0gJ3BlbmRpbmcnIHx8IHJvdy5pbmRleCA8PSBjdXJyZW50Um93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBpc0NvbW1pdHRlZCA9IHJvdy5jb21taXR0ZWRPcHRpb24gPT09IG9wdGlvbi5pZDtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5GYWN0aW9uUGF0aCA9IHBhdGhzLmZhY3Rpb25QYXRoLmluY2x1ZGVzKG9wdGlvbi5pZCk7XG4gICAgICAgICAgICBjb25zdCBpc1dpbm5lciA9IHZpc2libGUgJiYgKGlzQ29tbWl0dGVkIHx8IGlzSW5GYWN0aW9uUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSByb3cuaW5kZXggPT09IGN1cnJlbnRSb3dJbmRleCAmJiByb3cucGhhc2UgIT09ICdwZW5kaW5nJztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGcga2V5PXtvcHRpb24uaWR9PlxuICAgICAgICAgICAgICAgIHsvKiBXaW5uZXIgZ2xvdyByaW5nICovfVxuICAgICAgICAgICAgICAgIHtpc1dpbm5lciAmJiAoXG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICAgIGN4PXtwb3MueH1cbiAgICAgICAgICAgICAgICAgICAgY3k9e3Bvcy55fVxuICAgICAgICAgICAgICAgICAgICByPXtXSU5ORVJfUkFESVVTICsgNn1cbiAgICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCIjZmZmXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9ezAuMTJ9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ2N4IDEuNXMgZWFzZS1pbi1vdXQsIGN5IDEuNXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHsvKiBDdXJyZW50IHJvdyBnbG93ICovfVxuICAgICAgICAgICAgICAgIHtpc0N1cnJlbnQgJiYgIWlzV2lubmVyICYmIChcbiAgICAgICAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgY3g9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICAgIHI9e0RPVF9SQURJVVMgKyA4fVxuICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM0YWRlODBcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17MC40fVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB7LyogTWFpbiBub2RlIGNpcmNsZSAqL31cbiAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICBjeD17cG9zLnh9XG4gICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICByPXtpc1dpbm5lciA/IFdJTk5FUl9SQURJVVMgOiBET1RfUkFESVVTfVxuICAgICAgICAgICAgICAgICAgZmlsbD17IXZpc2libGUgPyAnIzFhMWEyMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjM2EzYTQ0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17IXZpc2libGUgPyAnIzJhMmEzMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjNGE0YTU0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXt2aXNpYmxlID8gMS41IDogMC41fVxuICAgICAgICAgICAgICAgICAgb3BhY2l0eT17dmlzaWJsZSA/IDEgOiAwLjM1fVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgPyAnciAwLjRzIGVhc2UsIGZpbGwgMC40cyBlYXNlLCBvcGFjaXR5IDAuNHMgZWFzZSdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0LCByIDAuNHMgZWFzZSwgZmlsbCAwLjRzIGVhc2UsIG9wYWNpdHkgMC40cyBlYXNlJyxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7LyogT3B0aW9uIGxhYmVsICovfVxuICAgICAgICAgICAgICAgIHt2aXNpYmxlICYmIChcbiAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHg9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICB5PXtwb3MueSArIDF9XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXs5fVxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXs3MDB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGw9e2lzV2lubmVyID8gJyMwYjBiMGYnIDogJyM2NjYnfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICd4IDEuNXMgZWFzZS1pbi1vdXQsIHkgMS41cyBlYXNlLWluLW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7U3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIG9wdElkeCl9XG4gICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApfVxuXG4gICAgICAgIHsvKiBSb3cgbGFiZWxzICovfVxuICAgICAgICB7cm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHZpc2libGUgPSByb3cucGhhc2UgIT09ICdwZW5kaW5nJyB8fCByb3cuaW5kZXggPD0gY3VycmVudFJvd0luZGV4O1xuICAgICAgICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjb25zdCBsZWZ0UG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCAwKTtcbiAgICAgICAgICBjb25zdCBsYWJlbFggPSBpc1RyZWVNb2RlXG4gICAgICAgICAgICA/IE1hdGgubWluKGxlZnRQb3MueCwgZ2V0UG9zaXRpb24ocm93LmluZGV4LCBPUFRJT05TX1BFUl9ST1cgLSAxKS54KSAtIDMwXG4gICAgICAgICAgICA6IGxlZnRQb3MueCAtIDQwO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgIGtleT17YGxhYmVsLSR7cm93LmluZGV4fWB9XG4gICAgICAgICAgICAgIHg9e2xhYmVsWH1cbiAgICAgICAgICAgICAgeT17bGVmdFBvcy55ICsgMX1cbiAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cImVuZFwiXG4gICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9ezEwfVxuICAgICAgICAgICAgICBmaWxsPVwiIzQ0NFwiXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ3ggMS41cyBlYXNlLWluLW91dCwgeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3Jvdy5sYWJlbCB8fCBgUiR7cm93LmluZGV4ICsgMX1gfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICk7XG59KTtcblxuLy8g4pSA4pSA4pSAIFN0eWxlcyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuY29uc3Qgc3R5bGVzID0ge1xuICBjb250YWluZXI6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLFxuXG4gIHN2Zzoge1xuICAgIHdpZHRoOiAnOTAlJyxcbiAgICBoZWlnaHQ6ICc5MCUnLFxuICAgIG1heFdpZHRoOiBTVkdfV0lEVEgsXG4gICAgbWF4SGVpZ2h0OiBTVkdfSEVJR0hULFxuICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsXG59O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwibWVtbyIsIlNWR19XSURUSCIsIlNWR19IRUlHSFQiLCJPUFRJT05TX1BFUl9ST1ciLCJGQUNUSU9OX0NPTE9SUyIsIkRPVF9SQURJVVMiLCJXSU5ORVJfUkFESVVTIiwiR1JJRF9DT0xfU1BBQ0lORyIsIkdSSURfUk9XX1NQQUNJTkciLCJUUkFOU0lUSU9OX0RVUkFUSU9OX01TIiwiZ3JpZFBvc2l0aW9uIiwicm93Iiwib3B0aW9uIiwiY29uZmlnIiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsImRlbHRhUG9zaXRpb24iLCJqaXR0ZXIiLCJ5MCIsInlUb3AiLCJ0b3RhbEgiLCJ0Iiwicm93cyIsInNwcmVhZCIsIk1hdGgiLCJwb3ciLCJvZmZzZXRzIiwia2V5IiwiZHgiLCJkeSIsImludGVycG9sYXRlZFBvc2l0aW9uIiwicHJvZ3Jlc3MiLCJncmlkUG9zIiwiZGVsdGFQb3MiLCJnZW5lcmF0ZURlbHRhSml0dGVyIiwic2VlZCIsIm51bVJvd3MiLCJzIiwicmFuZCIsIm9wdCIsIm1hZ25pdHVkZSIsImRpc3RhbmNlIiwicDEiLCJwMiIsInNxcnQiLCJjYXRtdWxsUm9tUGF0aCIsInBvaW50cyIsImFscGhhIiwibGVuZ3RoIiwiZXh0ZW5kZWQiLCJwYXRoIiwiaSIsInAwIiwicDMiLCJkMSIsImQyIiwiZDMiLCJkMWEiLCJkMmEiLCJkM2EiLCJkMWEyIiwiZDJhMiIsImQzYTIiLCJkZW5vbTEiLCJjcDF4IiwiY3AxeSIsImRlbm9tMiIsImNwMngiLCJjcDJ5IiwicGFyc2VPcHRpb25JbmRleCIsIm9wdGlvbklkIiwibWF0Y2giLCJwYXJzZUludCIsImVhc2VJbk91dEN1YmljIiwiQW5pbWF0ZWRQYXRoIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsImRhc2hBcnJheSIsIm9wYWNpdHkiLCJkZWxheSIsImR1cmF0aW9uIiwicGF0aFJlZiIsInBhdGhMZW5ndGgiLCJzZXRQYXRoTGVuZ3RoIiwiYW5pbWF0ZWRMZW5ndGgiLCJzZXRBbmltYXRlZExlbmd0aCIsImlzQW5pbWF0aW5nIiwic2V0SXNBbmltYXRpbmciLCJjdXJyZW50IiwidG90YWxMZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInRpbWVyIiwic2V0VGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYXJUaW1lb3V0IiwibmV3U2VnbWVudExlbmd0aCIsImVmZmVjdGl2ZURhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJyZWYiLCJkIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJTb25nVHJlZSIsInBhdGhzIiwiY3VycmVudFJvd0luZGV4Iiwic2hvd1BoYXNlIiwiZmluYWxlUGhhc2UiLCJjdXJyZW50RmluYWxlVGltZWxpbmUiLCJmYWN0aW9uQ29sb3JzIiwiYXVkaWVuY2VUaW1lbGluZXMiLCJkaXYiLCJzdHlsZXMiLCJjb250YWluZXIiLCJmb250U2l6ZSIsInRleHRBbGlnbiIsImxheW91dE1vZGUiLCJzZXRMYXlvdXRNb2RlIiwibGF5b3V0UHJvZ3Jlc3MiLCJzZXRMYXlvdXRQcm9ncmVzcyIsIm1vY2tUaW1lbGluZXMiLCJ0aW1lbGluZXMiLCJyIiwib3B0aW9uSWR4IiwiZmxvb3IiLCJwdXNoIiwidXNlcklkIiwiZmlnVHJlZVJlc3BvbnNlIiwiaGFybW9uaWNHcm91cCIsInJldmVhbGVkVGltZWxpbmVzIiwic2V0UmV2ZWFsZWRUaW1lbGluZXMiLCJlZmZlY3RpdmVUaW1lbGluZXMiLCJkZWx0YUppdHRlciIsImxheW91dENvbmZpZyIsIm9wdGlvbnMiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImFuaW1hdGUiLCJlbGFwc2VkIiwibWluIiwiZWFzZWQiLCJmaW5kIiwicHJldiIsImdldFBvc2l0aW9uIiwiZmFjdGlvblBhdGhTdHJpbmciLCJmYWN0aW9uUGF0aCIsIm1hcCIsInJvd0lkeCIsInBvcHVsYXJQYXRoU3RyaW5nIiwicG9wdWxhclBhdGgiLCJhdWRpZW5jZVBhdGhTdHJpbmdzIiwidGltZWxpbmUiLCJpZHgiLCJmYWN0aW9uSW5kZXgiLCJpc1RyZWVNb2RlIiwiaXNUcmFuc2l0aW9uaW5nIiwiaGFzQXVkaWVuY2VQYXRocyIsInN2ZyIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiYXAiLCJvcHRJZHgiLCJwb3MiLCJpbmRleCIsInZpc2libGUiLCJwaGFzZSIsImlzQ29tbWl0dGVkIiwiY29tbWl0dGVkT3B0aW9uIiwiaWQiLCJpc0luRmFjdGlvblBhdGgiLCJpbmNsdWRlcyIsImlzV2lubmVyIiwiaXNDdXJyZW50IiwiZyIsImNpcmNsZSIsImN4IiwiY3kiLCJ0ZXh0IiwidGV4dEFuY2hvciIsImRvbWluYW50QmFzZWxpbmUiLCJmb250V2VpZ2h0IiwicG9pbnRlckV2ZW50cyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImxlZnRQb3MiLCJsYWJlbFgiLCJsYWJlbCIsInBvc2l0aW9uIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIm92ZXJmbG93IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SongTree.tsx\n"));

/***/ })

});