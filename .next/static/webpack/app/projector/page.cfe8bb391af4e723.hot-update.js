"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projector/page",{

/***/ "(app-pages-browser)/./hooks/useSocket.ts":
/*!****************************!*\
  !*** ./hooks/useSocket.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSocket: function() { return /* binding */ useSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./lib/storage.ts\");\n/**\n * useSocket Hook\n *\n * Manages Socket.IO connection with automatic reconnection and exponential backoff.\n * Handles client identity persistence and state synchronization.\n */ /* __next_internal_client_entry_do_not_use__ useSocket auto */ \n\n\nconst MAX_BACKOFF_MS = 10000; // 10 seconds\nconst INITIAL_BACKOFF_MS = 1000; // 1 second\nfunction useSocket(param) {\n    let { showId, seatId = null, mode } = param;\n    const [socket, setSocket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"disconnected\");\n    const [userId, setUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const reconnectAttempts = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const reconnectTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null); // Track socket for cleanup\n    const lastPongTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Date.now()); // Track last successful pong\n    const isConnecting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false); // Prevent concurrent connection attempts\n    // Calculate exponential backoff delay\n    const getBackoffDelay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const delay = Math.min(INITIAL_BACKOFF_MS * Math.pow(2, reconnectAttempts.current), MAX_BACKOFF_MS);\n        return delay;\n    }, []);\n    // Connect or reconnect to socket\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _socketRef_current;\n        if (false) {}\n        // Prevent concurrent connection attempts\n        if (isConnecting.current) {\n            console.log(\"[Socket] Connection attempt already in progress, skipping\");\n            return;\n        }\n        // Prevent double connections only if truly connected AND recently received pong\n        const timeSinceLastPong = Date.now() - lastPongTime.current;\n        const CONNECTION_HEALTH_THRESHOLD = 30000; // 30 seconds\n        if (((_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected) && timeSinceLastPong < CONNECTION_HEALTH_THRESHOLD) {\n            console.log(\"[Socket] Already connected and healthy, skipping\");\n            return;\n        }\n        // Clean up existing socket if any\n        if (socketRef.current) {\n            console.log(\"[Socket] Cleaning up stale socket\");\n            socketRef.current.disconnect();\n            socketRef.current = null;\n        }\n        isConnecting.current = true;\n        setConnectionState(\"connecting\");\n        // Get or create client identity\n        const identity = (0,_lib_storage__WEBPACK_IMPORTED_MODULE_2__.getOrCreateIdentity)(showId, seatId);\n        setUserId(identity.userId);\n        // Create socket connection\n        const newSocket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)({\n            path: \"/socket.io\",\n            transports: [\n                \"websocket\",\n                \"polling\"\n            ],\n            reconnection: false\n        });\n        // Track socket in ref for cleanup\n        socketRef.current = newSocket;\n        // Connection established\n        newSocket.on(\"connect\", ()=>{\n            console.log(\"[Socket] Connected\");\n            setConnectionState(\"connected\");\n            reconnectAttempts.current = 0;\n            isConnecting.current = false;\n            lastPongTime.current = Date.now();\n            // Send join event\n            newSocket.emit(\"join\", {\n                userId: identity.userId,\n                showId: identity.showId,\n                seatId: identity.seatId,\n                mode,\n                lastVersion: identity.lastVersion\n            });\n        });\n        // Respond to server heartbeat pings\n        newSocket.on(\"ping\", ()=>{\n            newSocket.emit(\"pong\");\n            lastPongTime.current = Date.now();\n        });\n        // Connection error\n        newSocket.on(\"connect_error\", (error)=>{\n            console.error(\"[Socket] Connection error:\", error);\n            setConnectionState(\"reconnecting\");\n            isConnecting.current = false;\n            scheduleReconnect();\n        });\n        // Disconnection\n        newSocket.on(\"disconnect\", (reason)=>{\n            console.log(\"[Socket] Disconnected:\", reason);\n            setConnectionState(\"reconnecting\");\n            isConnecting.current = false;\n            // Only auto-reconnect if not a manual disconnect\n            if (reason !== \"io client disconnect\") {\n                scheduleReconnect();\n            }\n        });\n        // State sync - update our version\n        newSocket.on(\"state_sync\", (data)=>{\n            var _data_state;\n            if ((_data_state = data.state) === null || _data_state === void 0 ? void 0 : _data_state.version) {\n                (0,_lib_storage__WEBPACK_IMPORTED_MODULE_2__.updateLastVersion)(data.state.version);\n            }\n        });\n        // Forced reconnect from server\n        newSocket.on(\"force_reconnect\", (data)=>{\n            console.log(\"[Socket] Force reconnect:\", data.reason);\n            newSocket.disconnect();\n            setTimeout(()=>connect(), 100);\n        });\n        setSocket(newSocket);\n    }, [\n        showId,\n        seatId,\n        mode\n    ]);\n    // Schedule reconnection with exponential backoff\n    const scheduleReconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (reconnectTimeout.current) {\n            clearTimeout(reconnectTimeout.current);\n        }\n        const delay = getBackoffDelay();\n        console.log(\"[Socket] Reconnecting in \".concat(delay, \"ms (attempt \").concat(reconnectAttempts.current + 1, \")\"));\n        reconnectTimeout.current = setTimeout(()=>{\n            reconnectAttempts.current += 1;\n            connect();\n        }, delay);\n    }, [\n        connect,\n        getBackoffDelay\n    ]);\n    // Manual reconnect\n    const reconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (socketRef.current) {\n            socketRef.current.disconnect();\n            socketRef.current = null;\n        }\n        reconnectAttempts.current = 0;\n        connect();\n    }, [\n        connect\n    ]);\n    // Emit helper\n    const emit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, data)=>{\n        if (socket && socket.connected) {\n            socket.emit(event, data);\n        } else {\n            console.warn(\"[Socket] Cannot emit - not connected:\", event);\n        }\n    }, [\n        socket\n    ]);\n    // Initialize connection on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        connect();\n        return ()=>{\n            if (reconnectTimeout.current) {\n                clearTimeout(reconnectTimeout.current);\n            }\n            // Use ref for cleanup since state may be stale\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            // Reset connecting flag for React Strict Mode double-mount\n            isConnecting.current = false;\n        };\n    }, [\n        connect\n    ]);\n    // Handle page visibility changes (app backgrounding/foregrounding)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (false) {}\n        const checkConnectionHealth = ()=>{\n            const timeSinceLastPong = Date.now() - lastPongTime.current;\n            const CONNECTION_STALE_THRESHOLD = 30000; // 30 seconds\n            // Force reconnect if:\n            // 1. No socket exists, or\n            // 2. Socket is not connected, or\n            // 3. Haven't received pong in a while (stale connection)\n            if (!socketRef.current || !socketRef.current.connected || timeSinceLastPong > CONNECTION_STALE_THRESHOLD) {\n                var _socketRef_current;\n                console.log(\"[Socket] Connection stale or broken, forcing reconnect\", {\n                    hasSocket: !!socketRef.current,\n                    isConnected: (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected,\n                    timeSinceLastPong\n                });\n                // Force reconnect\n                if (socketRef.current) {\n                    socketRef.current.disconnect();\n                    socketRef.current = null;\n                }\n                isConnecting.current = false;\n                reconnectAttempts.current = 0;\n                connect();\n            } else {\n                console.log(\"[Socket] Connection healthy\");\n            }\n        };\n        const handleVisibilityChange = ()=>{\n            // When page becomes visible again\n            if (document.visibilityState === \"visible\") {\n                console.log(\"[Socket] Page became visible, checking connection health\");\n                checkConnectionHealth();\n            }\n        };\n        const handleFocus = ()=>{\n            // When window gains focus (backup for visibility API)\n            console.log(\"[Socket] Window focused, checking connection health\");\n            checkConnectionHealth();\n        };\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n        window.addEventListener(\"focus\", handleFocus);\n        return ()=>{\n            document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"focus\", handleFocus);\n        };\n    }, [\n        connect\n    ]);\n    return {\n        socket,\n        connectionState,\n        userId,\n        emit,\n        reconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVNvY2tldC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztDQUtDLGtFQUlnRTtBQUNuQjtBQUV5QjtBQWtCdkUsTUFBTU8saUJBQWlCLE9BQU8sYUFBYTtBQUMzQyxNQUFNQyxxQkFBcUIsTUFBTSxXQUFXO0FBRXJDLFNBQVNDLFVBQVUsS0FBaUQ7UUFBakQsRUFBRUMsTUFBTSxFQUFFQyxTQUFTLElBQUksRUFBRUMsSUFBSSxFQUFvQixHQUFqRDtJQUN4QixNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR2IsK0NBQVFBLENBQWdCO0lBQ3BELE1BQU0sQ0FBQ2MsaUJBQWlCQyxtQkFBbUIsR0FBR2YsK0NBQVFBLENBQWtCO0lBQ3hFLE1BQU0sQ0FBQ2dCLFFBQVFDLFVBQVUsR0FBR2pCLCtDQUFRQSxDQUFnQjtJQUVwRCxNQUFNa0Isb0JBQW9CaEIsNkNBQU1BLENBQUM7SUFDakMsTUFBTWlCLG1CQUFtQmpCLDZDQUFNQSxDQUF3QjtJQUN2RCxNQUFNa0IsWUFBWWxCLDZDQUFNQSxDQUFnQixPQUFPLDJCQUEyQjtJQUMxRSxNQUFNbUIsZUFBZW5CLDZDQUFNQSxDQUFTb0IsS0FBS0MsR0FBRyxLQUFLLDZCQUE2QjtJQUM5RSxNQUFNQyxlQUFldEIsNkNBQU1BLENBQUMsUUFBUSx5Q0FBeUM7SUFFN0Usc0NBQXNDO0lBQ3RDLE1BQU11QixrQkFBa0J4QixrREFBV0EsQ0FBQztRQUNsQyxNQUFNeUIsUUFBUUMsS0FBS0MsR0FBRyxDQUNwQnJCLHFCQUFxQm9CLEtBQUtFLEdBQUcsQ0FBQyxHQUFHWCxrQkFBa0JZLE9BQU8sR0FDMUR4QjtRQUVGLE9BQU9vQjtJQUNULEdBQUcsRUFBRTtJQUVMLGlDQUFpQztJQUNqQyxNQUFNSyxVQUFVOUIsa0RBQVdBLENBQUM7WUFhdEJtQjtRQVpKLElBQUksS0FBa0IsRUFBYSxFQUFPO1FBRTFDLHlDQUF5QztRQUN6QyxJQUFJSSxhQUFhTSxPQUFPLEVBQUU7WUFD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b0JOO1lBQ2pESyxPQUFPQyxtQkFBbUIsQ0FBQyxTQUFTSDtRQUN0QztJQUNGLEdBQUc7UUFBQ2pDO0tBQVE7SUFFWixPQUFPO1FBQ0xuQjtRQUNBRTtRQUNBRTtRQUNBNEI7UUFDQVU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVNvY2tldC50cz9kNDA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdXNlU29ja2V0IEhvb2tcbiAqXG4gKiBNYW5hZ2VzIFNvY2tldC5JTyBjb25uZWN0aW9uIHdpdGggYXV0b21hdGljIHJlY29ubmVjdGlvbiBhbmQgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqIEhhbmRsZXMgY2xpZW50IGlkZW50aXR5IHBlcnNpc3RlbmNlIGFuZCBzdGF0ZSBzeW5jaHJvbml6YXRpb24uXG4gKi9cblxuJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IHR5cGUgeyBVc2VySWQsIFNob3dJZCwgU2VhdElkIH0gZnJvbSAnQC9jb25kdWN0b3IvdHlwZXMnO1xuaW1wb3J0IHsgZ2V0T3JDcmVhdGVJZGVudGl0eSwgdXBkYXRlTGFzdFZlcnNpb24gfSBmcm9tICdAL2xpYi9zdG9yYWdlJztcblxuZXhwb3J0IHR5cGUgQ29ubmVjdGlvblN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCcgfCAnY29ubmVjdGluZycgfCAnY29ubmVjdGVkJyB8ICdyZWNvbm5lY3RpbmcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvY2tldEhvb2tSZXR1cm4ge1xuICBzb2NrZXQ6IFNvY2tldCB8IG51bGw7XG4gIGNvbm5lY3Rpb25TdGF0ZTogQ29ubmVjdGlvblN0YXRlO1xuICB1c2VySWQ6IFVzZXJJZCB8IG51bGw7XG4gIGVtaXQ6IChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IHZvaWQ7XG4gIHJlY29ubmVjdDogKCkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFVzZVNvY2tldE9wdGlvbnMge1xuICBzaG93SWQ6IFNob3dJZDtcbiAgc2VhdElkPzogU2VhdElkIHwgbnVsbDtcbiAgbW9kZTogJ2F1ZGllbmNlJyB8ICdwcm9qZWN0b3InIHwgJ2NvbnRyb2xsZXInO1xufVxuXG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEwMDAwOyAvLyAxMCBzZWNvbmRzXG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwOyAvLyAxIHNlY29uZFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ja2V0KHsgc2hvd0lkLCBzZWF0SWQgPSBudWxsLCBtb2RlIH06IFVzZVNvY2tldE9wdGlvbnMpOiBTb2NrZXRIb29rUmV0dXJuIHtcbiAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IHVzZVN0YXRlPFNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGU8Q29ubmVjdGlvblN0YXRlPignZGlzY29ubmVjdGVkJyk7XG4gIGNvbnN0IFt1c2VySWQsIHNldFVzZXJJZF0gPSB1c2VTdGF0ZTxVc2VySWQgfCBudWxsPihudWxsKTtcblxuICBjb25zdCByZWNvbm5lY3RBdHRlbXB0cyA9IHVzZVJlZigwKTtcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7IC8vIFRyYWNrIHNvY2tldCBmb3IgY2xlYW51cFxuICBjb25zdCBsYXN0UG9uZ1RpbWUgPSB1c2VSZWY8bnVtYmVyPihEYXRlLm5vdygpKTsgLy8gVHJhY2sgbGFzdCBzdWNjZXNzZnVsIHBvbmdcbiAgY29uc3QgaXNDb25uZWN0aW5nID0gdXNlUmVmKGZhbHNlKTsgLy8gUHJldmVudCBjb25jdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHNcblxuICAvLyBDYWxjdWxhdGUgZXhwb25lbnRpYWwgYmFja29mZiBkZWxheVxuICBjb25zdCBnZXRCYWNrb2ZmRGVsYXkgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIElOSVRJQUxfQkFDS09GRl9NUyAqIE1hdGgucG93KDIsIHJlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQpLFxuICAgICAgTUFYX0JBQ0tPRkZfTVNcbiAgICApO1xuICAgIHJldHVybiBkZWxheTtcbiAgfSwgW10pO1xuXG4gIC8vIENvbm5lY3Qgb3IgcmVjb25uZWN0IHRvIHNvY2tldFxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBjb25jdXJyZW50IGNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgICBpZiAoaXNDb25uZWN0aW5nLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBDb25uZWN0aW9uIGF0dGVtcHQgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGRvdWJsZSBjb25uZWN0aW9ucyBvbmx5IGlmIHRydWx5IGNvbm5lY3RlZCBBTkQgcmVjZW50bHkgcmVjZWl2ZWQgcG9uZ1xuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RQb25nID0gRGF0ZS5ub3coKSAtIGxhc3RQb25nVGltZS5jdXJyZW50O1xuICAgIGNvbnN0IENPTk5FQ1RJT05fSEVBTFRIX1RIUkVTSE9MRCA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG5cbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQ/LmNvbm5lY3RlZCAmJiB0aW1lU2luY2VMYXN0UG9uZyA8IENPTk5FQ1RJT05fSEVBTFRIX1RIUkVTSE9MRCkge1xuICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIEFscmVhZHkgY29ubmVjdGVkIGFuZCBoZWFsdGh5LCBza2lwcGluZycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIHNvY2tldCBpZiBhbnlcbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU29ja2V0XSBDbGVhbmluZyB1cCBzdGFsZSBzb2NrZXQnKTtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpc0Nvbm5lY3RpbmcuY3VycmVudCA9IHRydWU7XG4gICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG5cbiAgICAvLyBHZXQgb3IgY3JlYXRlIGNsaWVudCBpZGVudGl0eVxuICAgIGNvbnN0IGlkZW50aXR5ID0gZ2V0T3JDcmVhdGVJZGVudGl0eShzaG93SWQsIHNlYXRJZCk7XG4gICAgc2V0VXNlcklkKGlkZW50aXR5LnVzZXJJZCk7XG5cbiAgICAvLyBDcmVhdGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICBjb25zdCBuZXdTb2NrZXQgPSBpbyh7XG4gICAgICBwYXRoOiAnL3NvY2tldC5pbycsXG4gICAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCcsICdwb2xsaW5nJ10sXG4gICAgICByZWNvbm5lY3Rpb246IGZhbHNlLCAvLyBXZSdsbCBoYW5kbGUgcmVjb25uZWN0aW9uIG1hbnVhbGx5XG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayBzb2NrZXQgaW4gcmVmIGZvciBjbGVhbnVwXG4gICAgc29ja2V0UmVmLmN1cnJlbnQgPSBuZXdTb2NrZXQ7XG5cbiAgICAvLyBDb25uZWN0aW9uIGVzdGFibGlzaGVkXG4gICAgbmV3U29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIENvbm5lY3RlZCcpO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgIHJlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQgPSAwO1xuICAgICAgaXNDb25uZWN0aW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGxhc3RQb25nVGltZS5jdXJyZW50ID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gU2VuZCBqb2luIGV2ZW50XG4gICAgICBuZXdTb2NrZXQuZW1pdCgnam9pbicsIHtcbiAgICAgICAgdXNlcklkOiBpZGVudGl0eS51c2VySWQsXG4gICAgICAgIHNob3dJZDogaWRlbnRpdHkuc2hvd0lkLFxuICAgICAgICBzZWF0SWQ6IGlkZW50aXR5LnNlYXRJZCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGFzdFZlcnNpb246IGlkZW50aXR5Lmxhc3RWZXJzaW9uLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZXNwb25kIHRvIHNlcnZlciBoZWFydGJlYXQgcGluZ3NcbiAgICBuZXdTb2NrZXQub24oJ3BpbmcnLCAoKSA9PiB7XG4gICAgICBuZXdTb2NrZXQuZW1pdCgncG9uZycpO1xuICAgICAgbGFzdFBvbmdUaW1lLmN1cnJlbnQgPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuXG4gICAgLy8gQ29ubmVjdGlvbiBlcnJvclxuICAgIG5ld1NvY2tldC5vbignY29ubmVjdF9lcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignW1NvY2tldF0gQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBzZXRDb25uZWN0aW9uU3RhdGUoJ3JlY29ubmVjdGluZycpO1xuICAgICAgaXNDb25uZWN0aW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHNjaGVkdWxlUmVjb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICAvLyBEaXNjb25uZWN0aW9uXG4gICAgbmV3U29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKHJlYXNvbikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIERpc2Nvbm5lY3RlZDonLCByZWFzb24pO1xuICAgICAgc2V0Q29ubmVjdGlvblN0YXRlKCdyZWNvbm5lY3RpbmcnKTtcbiAgICAgIGlzQ29ubmVjdGluZy5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAgIC8vIE9ubHkgYXV0by1yZWNvbm5lY3QgaWYgbm90IGEgbWFudWFsIGRpc2Nvbm5lY3RcbiAgICAgIGlmIChyZWFzb24gIT09ICdpbyBjbGllbnQgZGlzY29ubmVjdCcpIHtcbiAgICAgICAgc2NoZWR1bGVSZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN0YXRlIHN5bmMgLSB1cGRhdGUgb3VyIHZlcnNpb25cbiAgICBuZXdTb2NrZXQub24oJ3N0YXRlX3N5bmMnLCAoZGF0YTogYW55KSA9PiB7XG4gICAgICBpZiAoZGF0YS5zdGF0ZT8udmVyc2lvbikge1xuICAgICAgICB1cGRhdGVMYXN0VmVyc2lvbihkYXRhLnN0YXRlLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRm9yY2VkIHJlY29ubmVjdCBmcm9tIHNlcnZlclxuICAgIG5ld1NvY2tldC5vbignZm9yY2VfcmVjb25uZWN0JywgKGRhdGE6IHsgcmVhc29uOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIEZvcmNlIHJlY29ubmVjdDonLCBkYXRhLnJlYXNvbik7XG4gICAgICBuZXdTb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBjb25uZWN0KCksIDEwMCk7XG4gICAgfSk7XG5cbiAgICBzZXRTb2NrZXQobmV3U29ja2V0KTtcbiAgfSwgW3Nob3dJZCwgc2VhdElkLCBtb2RlXSk7XG5cbiAgLy8gU2NoZWR1bGUgcmVjb25uZWN0aW9uIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICBjb25zdCBzY2hlZHVsZVJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocmVjb25uZWN0VGltZW91dC5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxheSA9IGdldEJhY2tvZmZEZWxheSgpO1xuICAgIGNvbnNvbGUubG9nKGBbU29ja2V0XSBSZWNvbm5lY3RpbmcgaW4gJHtkZWxheX1tcyAoYXR0ZW1wdCAke3JlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQgKyAxfSlgKTtcblxuICAgIHJlY29ubmVjdFRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVjb25uZWN0QXR0ZW1wdHMuY3VycmVudCArPSAxO1xuICAgICAgY29ubmVjdCgpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSwgW2Nvbm5lY3QsIGdldEJhY2tvZmZEZWxheV0pO1xuXG4gIC8vIE1hbnVhbCByZWNvbm5lY3RcbiAgY29uc3QgcmVjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZWNvbm5lY3RBdHRlbXB0cy5jdXJyZW50ID0gMDtcbiAgICBjb25uZWN0KCk7XG4gIH0sIFtjb25uZWN0XSk7XG5cbiAgLy8gRW1pdCBoZWxwZXJcbiAgY29uc3QgZW1pdCA9IHVzZUNhbGxiYWNrKChldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IHtcbiAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICAgIHNvY2tldC5lbWl0KGV2ZW50LCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdbU29ja2V0XSBDYW5ub3QgZW1pdCAtIG5vdCBjb25uZWN0ZWQ6JywgZXZlbnQpO1xuICAgIH1cbiAgfSwgW3NvY2tldF0pO1xuXG4gIC8vIEluaXRpYWxpemUgY29ubmVjdGlvbiBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbm5lY3QoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVjb25uZWN0VGltZW91dC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lb3V0LmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHJlZiBmb3IgY2xlYW51cCBzaW5jZSBzdGF0ZSBtYXkgYmUgc3RhbGVcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IGNvbm5lY3RpbmcgZmxhZyBmb3IgUmVhY3QgU3RyaWN0IE1vZGUgZG91YmxlLW1vdW50XG4gICAgICBpc0Nvbm5lY3RpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtjb25uZWN0XSk7XG5cbiAgLy8gSGFuZGxlIHBhZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIChhcHAgYmFja2dyb3VuZGluZy9mb3JlZ3JvdW5kaW5nKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hlY2tDb25uZWN0aW9uSGVhbHRoID0gKCkgPT4ge1xuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdFBvbmcgPSBEYXRlLm5vdygpIC0gbGFzdFBvbmdUaW1lLmN1cnJlbnQ7XG4gICAgICBjb25zdCBDT05ORUNUSU9OX1NUQUxFX1RIUkVTSE9MRCA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG5cbiAgICAgIC8vIEZvcmNlIHJlY29ubmVjdCBpZjpcbiAgICAgIC8vIDEuIE5vIHNvY2tldCBleGlzdHMsIG9yXG4gICAgICAvLyAyLiBTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgb3JcbiAgICAgIC8vIDMuIEhhdmVuJ3QgcmVjZWl2ZWQgcG9uZyBpbiBhIHdoaWxlIChzdGFsZSBjb25uZWN0aW9uKVxuICAgICAgaWYgKFxuICAgICAgICAhc29ja2V0UmVmLmN1cnJlbnQgfHxcbiAgICAgICAgIXNvY2tldFJlZi5jdXJyZW50LmNvbm5lY3RlZCB8fFxuICAgICAgICB0aW1lU2luY2VMYXN0UG9uZyA+IENPTk5FQ1RJT05fU1RBTEVfVEhSRVNIT0xEXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIENvbm5lY3Rpb24gc3RhbGUgb3IgYnJva2VuLCBmb3JjaW5nIHJlY29ubmVjdCcsIHtcbiAgICAgICAgICBoYXNTb2NrZXQ6ICEhc29ja2V0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgaXNDb25uZWN0ZWQ6IHNvY2tldFJlZi5jdXJyZW50Py5jb25uZWN0ZWQsXG4gICAgICAgICAgdGltZVNpbmNlTGFzdFBvbmcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvcmNlIHJlY29ubmVjdFxuICAgICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29ubmVjdGluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHJlY29ubmVjdEF0dGVtcHRzLmN1cnJlbnQgPSAwO1xuICAgICAgICBjb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnW1NvY2tldF0gQ29ubmVjdGlvbiBoZWFsdGh5Jyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAvLyBXaGVuIHBhZ2UgYmVjb21lcyB2aXNpYmxlIGFnYWluXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFBhZ2UgYmVjYW1lIHZpc2libGUsIGNoZWNraW5nIGNvbm5lY3Rpb24gaGVhbHRoJyk7XG4gICAgICAgIGNoZWNrQ29ubmVjdGlvbkhlYWx0aCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgIC8vIFdoZW4gd2luZG93IGdhaW5zIGZvY3VzIChiYWNrdXAgZm9yIHZpc2liaWxpdHkgQVBJKVxuICAgICAgY29uc29sZS5sb2coJ1tTb2NrZXRdIFdpbmRvdyBmb2N1c2VkLCBjaGVja2luZyBjb25uZWN0aW9uIGhlYWx0aCcpO1xuICAgICAgY2hlY2tDb25uZWN0aW9uSGVhbHRoKCk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cyk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgIH07XG4gIH0sIFtjb25uZWN0XSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzb2NrZXQsXG4gICAgY29ubmVjdGlvblN0YXRlLFxuICAgIHVzZXJJZCxcbiAgICBlbWl0LFxuICAgIHJlY29ubmVjdCxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwiaW8iLCJnZXRPckNyZWF0ZUlkZW50aXR5IiwidXBkYXRlTGFzdFZlcnNpb24iLCJNQVhfQkFDS09GRl9NUyIsIklOSVRJQUxfQkFDS09GRl9NUyIsInVzZVNvY2tldCIsInNob3dJZCIsInNlYXRJZCIsIm1vZGUiLCJzb2NrZXQiLCJzZXRTb2NrZXQiLCJjb25uZWN0aW9uU3RhdGUiLCJzZXRDb25uZWN0aW9uU3RhdGUiLCJ1c2VySWQiLCJzZXRVc2VySWQiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFRpbWVvdXQiLCJzb2NrZXRSZWYiLCJsYXN0UG9uZ1RpbWUiLCJEYXRlIiwibm93IiwiaXNDb25uZWN0aW5nIiwiZ2V0QmFja29mZkRlbGF5IiwiZGVsYXkiLCJNYXRoIiwibWluIiwicG93IiwiY3VycmVudCIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwidGltZVNpbmNlTGFzdFBvbmciLCJDT05ORUNUSU9OX0hFQUxUSF9USFJFU0hPTEQiLCJjb25uZWN0ZWQiLCJkaXNjb25uZWN0IiwiaWRlbnRpdHkiLCJuZXdTb2NrZXQiLCJwYXRoIiwidHJhbnNwb3J0cyIsInJlY29ubmVjdGlvbiIsIm9uIiwiZW1pdCIsImxhc3RWZXJzaW9uIiwiZXJyb3IiLCJzY2hlZHVsZVJlY29ubmVjdCIsInJlYXNvbiIsImRhdGEiLCJzdGF0ZSIsInZlcnNpb24iLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicmVjb25uZWN0IiwiZXZlbnQiLCJ3YXJuIiwiY2hlY2tDb25uZWN0aW9uSGVhbHRoIiwiQ09OTkVDVElPTl9TVEFMRV9USFJFU0hPTEQiLCJoYXNTb2NrZXQiLCJpc0Nvbm5lY3RlZCIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImhhbmRsZUZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndpbmRvdyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSocket.ts\n"));

/***/ })

});