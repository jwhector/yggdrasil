"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/projector/page",{

/***/ "(app-pages-browser)/./components/SongTree.tsx":
/*!*********************************!*\
  !*** ./components/SongTree.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SongTree: function() { return /* binding */ SongTree; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * SongTree Component\n *\n * Core visualization showing the song construction as a tree of options.\n * Displays dual paths: faction path (solid) and popular path (ghost/dashed).\n *\n * Features:\n * - Bottom-to-top row progression (row 0 at bottom)\n * - Grid layout during 'running' phase\n * - River delta layout during 'finale' phase (tight root, organically spreading tributaries)\n * - Smooth Catmull-Rom curved paths\n * - Animated individual audience paths during finale\n */ /* __next_internal_client_entry_do_not_use__ SongTree auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n// ─── Constants ──────────────────────────────────────────────────────────────\nconst SVG_WIDTH = 800;\nconst SVG_HEIGHT = 700;\nconst OPTIONS_PER_ROW = 4;\nconst FACTION_COLORS = [\n    \"#e05c5c\",\n    \"#5cb8e0\",\n    \"#5ce08a\",\n    \"#e0c55c\"\n];\nconst DOT_RADIUS = 8;\nconst WINNER_RADIUS = 11;\n// Grid layout spacing\nconst GRID_COL_SPACING = 70;\nconst GRID_ROW_SPACING = 56;\n// Transition duration\nconst TRANSITION_DURATION_MS = 1500;\n// ─── Layout Functions ───────────────────────────────────────────────────────\n/**\n * Grid position - linear layout used during 'running' phase\n * Bottom-to-top: row 0 at bottom, higher rows at top\n */ function gridPosition(row, option, config) {\n    const { width, height } = config;\n    const x = width / 2 - GRID_COL_SPACING * 1.5 + option * GRID_COL_SPACING;\n    const y = height - 70 - row * GRID_ROW_SPACING;\n    return {\n        x,\n        y\n    };\n}\n/**\n * Delta position - river delta / tributary layout used during 'finale' phase\n * Single source at bottom, paths branch outward with organic spread.\n * Jitter increases with row depth for natural asymmetry.\n */ function deltaPosition(row, option, config, jitter) {\n    const { width, height } = config;\n    // Bottom-to-top Y positioning with increasing spacing toward the top\n    const y0 = height - 60;\n    const yTop = 60;\n    const totalH = y0 - yTop;\n    // Use a slight power curve so upper rows get more room to spread\n    const t = row / (config.rows - 1); // 0 at bottom, 1 at top\n    let y = y0 - t * totalH;\n    // Spread increases as a power curve — tight at the root, wide at the tips\n    const spread = 20 + Math.pow(row, 1.8) * 14;\n    // 4 options evenly distributed across the spread\n    const offsets = [\n        -1.5,\n        -0.5,\n        0.5,\n        1.5\n    ];\n    let x = width / 2 + offsets[option] * spread;\n    // Apply stable jitter — increases with row for organic feel\n    const key = \"\".concat(row, \"-\").concat(option);\n    if (jitter[key]) {\n        x += jitter[key].dx;\n        y += jitter[key].dy;\n    }\n    return {\n        x,\n        y\n    };\n}\n/**\n * Interpolate between grid and tree positions\n */ function interpolatedPosition(row, option, config, progress, jitter) {\n    const gridPos = gridPosition(row, option, config);\n    const deltaPos = deltaPosition(row, option, config, jitter);\n    return {\n        x: gridPos.x + (deltaPos.x - gridPos.x) * progress,\n        y: gridPos.y + (deltaPos.y - gridPos.y) * progress\n    };\n}\n/**\n * Generate stable jitter for delta layout.\n * Jitter magnitude increases with row index — tight at root, loose at tips.\n * Row 0 gets no jitter (common source), higher rows spread organically.\n */ function generateDeltaJitter(seed, numRows) {\n    let s = seed;\n    const rand = ()=>{\n        s = (s * 16807 + 0) % 2147483647;\n        return (s - 1) / 2147483646;\n    };\n    const jitter = {};\n    for(let row = 0; row < numRows; row++){\n        for(let opt = 0; opt < OPTIONS_PER_ROW; opt++){\n            // Scale jitter: none at row 0, increasing toward top rows\n            const magnitude = row <= 1 ? 0 : Math.pow(row - 1, 1.2) * 4;\n            jitter[\"\".concat(row, \"-\").concat(opt)] = {\n                dx: (rand() - 0.5) * magnitude,\n                dy: (rand() - 0.5) * magnitude * 0.6\n            };\n        }\n    }\n    return jitter;\n}\n// ─── Curve Generation ───────────────────────────────────────────────────────\n/**\n * Calculate distance between two points\n */ function distance(p1, p2) {\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n}\n/**\n * Generate a Catmull-Rom spline path string\n * Alpha 0.5 = centripetal (avoids cusps and self-intersections)\n */ function catmullRomPath(points) {\n    let alpha = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n    if (points.length === 0) return \"\";\n    if (points.length === 1) return \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    if (points.length === 2) {\n        return \"M \".concat(points[0].x, \",\").concat(points[0].y, \" L \").concat(points[1].x, \",\").concat(points[1].y);\n    }\n    // Duplicate first and last points for end tangents\n    const extended = [\n        points[0],\n        ...points,\n        points[points.length - 1]\n    ];\n    let path = \"M \".concat(points[0].x, \",\").concat(points[0].y);\n    for(let i = 1; i < extended.length - 2; i++){\n        const p0 = extended[i - 1];\n        const p1 = extended[i];\n        const p2 = extended[i + 1];\n        const p3 = extended[i + 2];\n        const d1 = distance(p0, p1);\n        const d2 = distance(p1, p2);\n        const d3 = distance(p2, p3);\n        // Avoid division by zero\n        if (d1 < 0.001 || d2 < 0.001 || d3 < 0.001) {\n            path += \" L \".concat(p2.x, \",\").concat(p2.y);\n            continue;\n        }\n        const d1a = Math.pow(d1, alpha);\n        const d2a = Math.pow(d2, alpha);\n        const d3a = Math.pow(d3, alpha);\n        const d1a2 = Math.pow(d1, 2 * alpha);\n        const d2a2 = Math.pow(d2, 2 * alpha);\n        const d3a2 = Math.pow(d3, 2 * alpha);\n        // Control point 1\n        const denom1 = 3 * d1a * (d1a + d2a);\n        const cp1x = denom1 !== 0 ? (d1a2 * p2.x - d2a2 * p0.x + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.x) / denom1 : (p1.x + p2.x) / 2;\n        const cp1y = denom1 !== 0 ? (d1a2 * p2.y - d2a2 * p0.y + (2 * d1a2 + 3 * d1a * d2a + d2a2) * p1.y) / denom1 : (p1.y + p2.y) / 2;\n        // Control point 2\n        const denom2 = 3 * d3a * (d3a + d2a);\n        const cp2x = denom2 !== 0 ? (d3a2 * p1.x - d2a2 * p3.x + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.x) / denom2 : (p1.x + p2.x) / 2;\n        const cp2y = denom2 !== 0 ? (d3a2 * p1.y - d2a2 * p3.y + (2 * d3a2 + 3 * d3a * d2a + d2a2) * p2.y) / denom2 : (p1.y + p2.y) / 2;\n        path += \" C \".concat(cp1x, \",\").concat(cp1y, \" \").concat(cp2x, \",\").concat(cp2y, \" \").concat(p2.x, \",\").concat(p2.y);\n    }\n    return path;\n}\n// ─── Utility Functions ──────────────────────────────────────────────────────\n/**\n * Parse option index from optionId (e.g., \"r0-opt2\" → 2)\n */ function parseOptionIndex(optionId) {\n    const match = optionId.match(/opt(\\d+)$/);\n    return match ? parseInt(match[1], 10) : 0;\n}\n/**\n * Easing function for smooth animation\n */ function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n}\nconst AnimatedPath = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_s(function AnimatedPath(param) {\n    let { path, color, strokeWidth, dashArray, opacity = 1, delay = 0, duration = 1200 } = param;\n    _s();\n    const pathRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [pathLength, setPathLength] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Track how much of the path we've already animated (revealed)\n    const animatedLengthRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Animation state: 'idle' | 'preparing' | 'animating'\n    const [animState, setAnimState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"idle\");\n    // Store the offset to animate from\n    const [targetOffset, setTargetOffset] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Measure path length when path changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!pathRef.current || !path) return;\n        const totalLength = pathRef.current.getTotalLength();\n        setPathLength(totalLength);\n    }, [\n        path\n    ]);\n    // Detect new segments and trigger animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (pathLength === 0) return;\n        const newSegmentLength = pathLength - animatedLengthRef.current;\n        if (newSegmentLength > 0.5) {\n            // New segment to animate - set up the starting offset\n            setTargetOffset(newSegmentLength);\n            setAnimState(\"preparing\");\n        }\n    }, [\n        pathLength\n    ]);\n    // Handle animation state machine\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (animState === \"preparing\") {\n            // Wait for the \"hidden\" state to render, then start animation\n            const raf = requestAnimationFrame(()=>{\n                requestAnimationFrame(()=>{\n                    const timer = setTimeout(()=>{\n                        setAnimState(\"animating\");\n                        // Mark this length as animated after the animation completes\n                        setTimeout(()=>{\n                            animatedLengthRef.current = pathLength;\n                            setAnimState(\"idle\");\n                        }, duration);\n                    }, delay);\n                    return ()=>clearTimeout(timer);\n                });\n            });\n            return ()=>cancelAnimationFrame(raf);\n        }\n    }, [\n        animState,\n        pathLength,\n        delay,\n        duration\n    ]);\n    if (!path) return null;\n    // Calculate dash offset based on animation state\n    let dashOffset = 0;\n    if (animState === \"preparing\") {\n        dashOffset = targetOffset; // Hidden - new segment not visible\n    } else if (animState === \"animating\") {\n        dashOffset = 0; // Revealed - animate to this\n    }\n    // When idle, offset is 0 (fully visible)\n    // For solid lines: use pathLength as single dash for animation\n    // For dashed lines: use the custom pattern (animation won't work as smoothly)\n    const effectiveDashArray = dashArray || \"\".concat(pathLength);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n        ref: pathRef,\n        d: path,\n        fill: \"none\",\n        stroke: color,\n        strokeWidth: strokeWidth,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        strokeDasharray: effectiveDashArray,\n        strokeDashoffset: dashOffset,\n        opacity: opacity,\n        style: {\n            transition: animState === \"animating\" ? \"stroke-dashoffset \".concat(duration, \"ms ease-in-out, opacity 1s ease\") : \"none\"\n        }\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 354,\n        columnNumber: 5\n    }, this);\n}, \"Gle3gVkvwGrGIX+aR+6XZv8mfsM=\"));\n_c = AnimatedPath;\n// ─── Main Component ─────────────────────────────────────────────────────────\nconst SongTree = /*#__PURE__*/ _s1((0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_c1 = _s1(function SongTree(param) {\n    let { rows, paths, currentRowIndex, showPhase, finalePhase, currentFinaleTimeline, factionColors = FACTION_COLORS, audienceTimelines } = param;\n    _s1();\n    // Defensive check: ensure rows exist\n    if (!rows || rows.length === 0) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: styles.container,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: \"#999\",\n                    fontSize: \"1.5rem\",\n                    textAlign: \"center\"\n                },\n                children: \"Loading song tree...\"\n            }, void 0, false, {\n                fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                lineNumber: 390,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 389,\n            columnNumber: 7\n        }, this);\n    }\n    // Layout state - always start in grid mode, let useEffect handle transition\n    const [layoutMode, setLayoutMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"tree\");\n    const [layoutProgress, setLayoutProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Generate mock audience timelines for testing (30 users with random paths)\n    const mockTimelines = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const timelines = [];\n        const numRows = rows.length;\n        // Seeded random for reproducibility\n        let seed = 42;\n        const rand = ()=>{\n            seed = (seed * 16807 + 0) % 2147483647;\n            return (seed - 1) / 2147483646;\n        };\n        for(let i = 0; i < 30; i++){\n            const path = [];\n            for(let r = 0; r < numRows; r++){\n                const optionIdx = Math.floor(rand() * OPTIONS_PER_ROW);\n                path.push(\"r\".concat(r, \"-opt\").concat(optionIdx));\n            }\n            timelines.push({\n                userId: \"mock-user-\".concat(i),\n                path: path,\n                figTreeResponse: \"\",\n                harmonicGroup: \"A\"\n            });\n        }\n        return timelines;\n    }, [\n        rows.length\n    ]);\n    // Accumulated audience timelines for finale\n    const [revealedTimelines, setRevealedTimelines] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Use provided timelines, or mock timelines for testing when in finale\n    const effectiveTimelines = audienceTimelines !== null && audienceTimelines !== void 0 ? audienceTimelines : showPhase === \"finale\" ? mockTimelines : [];\n    // Generate stable delta jitter\n    const deltaJitter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>generateDeltaJitter(123, rows.length), [\n        rows.length\n    ]);\n    // Layout configuration\n    const layoutConfig = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            width: SVG_WIDTH,\n            height: SVG_HEIGHT,\n            rows: rows.length,\n            options: OPTIONS_PER_ROW\n        }), [\n        rows.length\n    ]);\n    // Transition animation when entering finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showPhase === \"finale\" && layoutMode !== \"tree\") {\n            setLayoutMode(\"transitioning\");\n            const startTime = performance.now();\n            const animate = (now)=>{\n                const elapsed = now - startTime;\n                const progress = Math.min(elapsed / TRANSITION_DURATION_MS, 1);\n                const eased = easeInOutCubic(progress);\n                setLayoutProgress(eased);\n                if (progress < 1) {\n                    requestAnimationFrame(animate);\n                } else {\n                    setLayoutMode(\"tree\");\n                }\n            };\n            requestAnimationFrame(animate);\n        } else if (showPhase === \"running\" && layoutMode === \"tree\") {\n            // Reset to grid (instant) if returning to running\n            setLayoutMode(\"grid\");\n            setLayoutProgress(0);\n            setRevealedTimelines([]);\n        }\n    }, [\n        showPhase,\n        layoutMode\n    ]);\n    // Accumulate revealed timelines during finale\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (currentFinaleTimeline && !revealedTimelines.find((t)=>t.userId === currentFinaleTimeline.userId)) {\n            setRevealedTimelines((prev)=>[\n                    ...prev,\n                    currentFinaleTimeline\n                ]);\n        }\n    }, [\n        currentFinaleTimeline,\n        revealedTimelines\n    ]);\n    // Position function based on layout mode\n    const getPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((row, option)=>{\n        if (layoutMode === \"grid\" || layoutProgress === 0) {\n            return gridPosition(row, option, layoutConfig);\n        }\n        if (layoutMode === \"tree\" || layoutProgress === 1) {\n            return deltaPosition(row, option, layoutConfig, deltaJitter);\n        }\n        return interpolatedPosition(row, option, layoutConfig, layoutProgress, deltaJitter);\n    }, [\n        layoutMode,\n        layoutProgress,\n        layoutConfig,\n        deltaJitter\n    ]);\n    // Build full path strings for smooth Catmull-Rom curves\n    const factionPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.factionPath.length === 0) return \"\";\n        const points = paths.factionPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.factionPath,\n        getPosition\n    ]);\n    const popularPathString = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (paths.popularPath.length === 0) return \"\";\n        const points = paths.popularPath.map((optionId, rowIdx)=>{\n            const optionIdx = parseOptionIndex(optionId);\n            return getPosition(rowIdx, optionIdx);\n        });\n        return catmullRomPath(points);\n    }, [\n        paths.popularPath,\n        getPosition\n    ]);\n    // Build audience timeline path strings\n    const audiencePathStrings = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return effectiveTimelines.map((timeline, idx)=>{\n            const points = timeline.path.map((optionId, rowIdx)=>{\n                const optionIdx = parseOptionIndex(optionId);\n                return getPosition(rowIdx, optionIdx);\n            });\n            return {\n                userId: timeline.userId,\n                path: catmullRomPath(points),\n                // Determine faction from userId - for now use modulo as placeholder\n                // In production, this would come from user data\n                factionIndex: idx % 4\n            };\n        });\n    }, [\n        effectiveTimelines,\n        getPosition\n    ]);\n    const isTreeMode = layoutMode === \"tree\" || layoutProgress > 0;\n    const isTransitioning = layoutMode === \"transitioning\";\n    const hasAudiencePaths = effectiveTimelines.length > 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: styles.container,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n            style: styles.svg,\n            viewBox: \"0 0 \".concat(SVG_WIDTH, \" \").concat(SVG_HEIGHT),\n            preserveAspectRatio: \"xMidYMid meet\",\n            children: [\n                finalePhase === \"individual_timelines\" && audiencePathStrings.map((ap, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                        path: ap.path,\n                        color: factionColors[ap.factionIndex] || FACTION_COLORS[0],\n                        strokeWidth: 2,\n                        opacity: 0.5,\n                        delay: idx * 100,\n                        duration: 1000\n                    }, ap.userId, false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 551,\n                        columnNumber: 13\n                    }, this)),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: popularPathString,\n                    color: \"#666\",\n                    strokeWidth: 3,\n                    dashArray: \"8 4\",\n                    opacity: hasAudiencePaths ? 0.2 : 0.5,\n                    delay: 0,\n                    duration: paths.popularPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 563,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AnimatedPath, {\n                    path: factionPathString,\n                    color: \"#fff\",\n                    strokeWidth: 4,\n                    opacity: hasAudiencePaths ? 0.15 : 1,\n                    delay: 0,\n                    duration: paths.factionPath.length * 300\n                }, void 0, false, {\n                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                    lineNumber: 574,\n                    columnNumber: 9\n                }, this),\n                rows.map((row)=>row.options.map((option, optIdx)=>{\n                        const pos = getPosition(row.index, optIdx);\n                        const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                        const isCommitted = row.committedOption === option.id;\n                        const isInFactionPath = paths.factionPath.includes(option.id);\n                        const isWinner = visible && (isCommitted || isInFactionPath);\n                        const isCurrent = row.index === currentRowIndex && row.phase !== \"pending\";\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                            children: [\n                                isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: WINNER_RADIUS + 6,\n                                    fill: \"none\",\n                                    stroke: \"#fff\",\n                                    strokeWidth: 1,\n                                    opacity: 0.12,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 597,\n                                    columnNumber: 19\n                                }, this),\n                                isCurrent && !isWinner && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: DOT_RADIUS + 8,\n                                    fill: \"none\",\n                                    stroke: \"#4ade80\",\n                                    strokeWidth: 2,\n                                    opacity: 0.4,\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 612,\n                                    columnNumber: 19\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: pos.x,\n                                    cy: pos.y,\n                                    r: isWinner ? WINNER_RADIUS : DOT_RADIUS,\n                                    fill: !visible ? \"#1a1a22\" : isWinner ? \"#fff\" : \"#3a3a44\",\n                                    stroke: !visible ? \"#2a2a32\" : isWinner ? \"#fff\" : \"#4a4a54\",\n                                    strokeWidth: visible ? 1.5 : 0.5,\n                                    opacity: visible ? 1 : 0.35,\n                                    style: {\n                                        transition: isTransitioning ? \"r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\" : \"cx 1.5s ease-in-out, cy 1.5s ease-in-out, r 0.4s ease, fill 0.4s ease, opacity 0.4s ease\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 626,\n                                    columnNumber: 17\n                                }, this),\n                                visible && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                                    x: pos.x,\n                                    y: pos.y + 1,\n                                    textAnchor: \"middle\",\n                                    dominantBaseline: \"central\",\n                                    fontSize: 9,\n                                    fontWeight: 700,\n                                    fill: isWinner ? \"#0b0b0f\" : \"#666\",\n                                    style: {\n                                        transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\",\n                                        pointerEvents: \"none\"\n                                    },\n                                    children: String.fromCharCode(65 + optIdx)\n                                }, void 0, false, {\n                                    fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                                    lineNumber: 642,\n                                    columnNumber: 19\n                                }, this)\n                            ]\n                        }, option.id, true, {\n                            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                            lineNumber: 594,\n                            columnNumber: 15\n                        }, this);\n                    })),\n                rows.map((row)=>{\n                    const visible = row.phase !== \"pending\" || row.index <= currentRowIndex;\n                    if (!visible) return null;\n                    const leftPos = getPosition(row.index, 0);\n                    const labelX = isTreeMode ? Math.min(leftPos.x, getPosition(row.index, OPTIONS_PER_ROW - 1).x) - 30 : leftPos.x - 40;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"text\", {\n                        x: labelX,\n                        y: leftPos.y + 1,\n                        textAnchor: \"end\",\n                        dominantBaseline: \"central\",\n                        fontSize: 10,\n                        fill: \"#444\",\n                        style: {\n                            transition: isTransitioning ? \"none\" : \"x 1.5s ease-in-out, y 1.5s ease-in-out\"\n                        },\n                        children: row.label || \"R\".concat(row.index + 1)\n                    }, \"label-\".concat(row.index), false, {\n                        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n                        lineNumber: 674,\n                        columnNumber: 13\n                    }, this);\n                })\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n            lineNumber: 543,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/jared/Documents/Projects/yggdrasil/components/SongTree.tsx\",\n        lineNumber: 542,\n        columnNumber: 5\n    }, this);\n}, \"TlFJbxj31wLd2Hy65hJEI0pr8MU=\")), \"TlFJbxj31wLd2Hy65hJEI0pr8MU=\");\n_c2 = SongTree;\n// ─── Styles ─────────────────────────────────────────────────────────────────\nconst styles = {\n    container: {\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100vh\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        overflow: \"hidden\"\n    },\n    svg: {\n        width: \"90%\",\n        height: \"90%\",\n        maxWidth: SVG_WIDTH,\n        maxHeight: SVG_HEIGHT\n    }\n};\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AnimatedPath\");\n$RefreshReg$(_c1, \"SongTree$memo\");\n$RefreshReg$(_c2, \"SongTree\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU29uZ1RyZWUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0NBWUM7O0FBSStFO0FBOENoRiwrRUFBK0U7QUFFL0UsTUFBTU0sWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGtCQUFrQjtBQUV4QixNQUFNQyxpQkFBaUI7SUFBQztJQUFXO0lBQVc7SUFBVztDQUFVO0FBQ25FLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsZ0JBQWdCO0FBRXRCLHNCQUFzQjtBQUN0QixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsbUJBQW1CO0FBRXpCLHNCQUFzQjtBQUN0QixNQUFNQyx5QkFBeUI7QUFFL0IsK0VBQStFO0FBRS9FOzs7Q0FHQyxHQUNELFNBQVNDLGFBQWFDLEdBQVcsRUFBRUMsTUFBYyxFQUFFQyxNQUFvQjtJQUNyRSxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO0lBQzFCLE1BQU1HLElBQUlGLFFBQVEsSUFBSVAsbUJBQW1CLE1BQU1LLFNBQVNMO0lBQ3hELE1BQU1VLElBQUlGLFNBQVMsS0FBS0osTUFBTUg7SUFDOUIsT0FBTztRQUFFUTtRQUFHQztJQUFFO0FBQ2hCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDLGNBQ1BQLEdBQVcsRUFDWEMsTUFBYyxFQUNkQyxNQUFvQixFQUNwQk0sTUFBa0Q7SUFFbEQsTUFBTSxFQUFFTCxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUUxQixxRUFBcUU7SUFDckUsTUFBTU8sS0FBS0wsU0FBUztJQUNwQixNQUFNTSxPQUFPO0lBQ2IsTUFBTUMsU0FBU0YsS0FBS0M7SUFFcEIsaUVBQWlFO0lBQ2pFLE1BQU1FLElBQUlaLE1BQU9FLENBQUFBLE9BQU9XLElBQUksR0FBRyxJQUFJLHdCQUF3QjtJQUMzRCxJQUFJUCxJQUFJRyxLQUFLRyxJQUFJRDtJQUVqQiwwRUFBMEU7SUFDMUUsTUFBTUcsU0FBUyxL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QUN6QztrQ0FFQzNKLElBQUkwTCxLQUFLLElBQUksSUFBa0IsT0FBZDFMLElBQUltSyxLQUFLLEdBQUc7dUJBWHpCLFNBQW1CLE9BQVZuSyxJQUFJbUssS0FBSzs7Ozs7Z0JBYzdCOzs7Ozs7Ozs7Ozs7QUFJUixxRUFBRzs7QUFFSCwrRUFBK0U7QUFFL0UsTUFBTXBELFNBQVM7SUFDYkMsV0FBVztRQUNUMkUsVUFBVTtRQUNWeEwsT0FBTztRQUNQQyxRQUFRO1FBQ1J3TCxTQUFTO1FBQ1RDLFlBQVk7UUFDWkMsZ0JBQWdCO1FBQ2hCQyxVQUFVO0lBQ1o7SUFFQWxDLEtBQUs7UUFDSDFKLE9BQU87UUFDUEMsUUFBUTtRQUNSNEwsVUFBVTFNO1FBQ1YyTSxXQUFXMU07SUFDYjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU29uZ1RyZWUudHN4P2I5ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTb25nVHJlZSBDb21wb25lbnRcbiAqXG4gKiBDb3JlIHZpc3VhbGl6YXRpb24gc2hvd2luZyB0aGUgc29uZyBjb25zdHJ1Y3Rpb24gYXMgYSB0cmVlIG9mIG9wdGlvbnMuXG4gKiBEaXNwbGF5cyBkdWFsIHBhdGhzOiBmYWN0aW9uIHBhdGggKHNvbGlkKSBhbmQgcG9wdWxhciBwYXRoIChnaG9zdC9kYXNoZWQpLlxuICpcbiAqIEZlYXR1cmVzOlxuICogLSBCb3R0b20tdG8tdG9wIHJvdyBwcm9ncmVzc2lvbiAocm93IDAgYXQgYm90dG9tKVxuICogLSBHcmlkIGxheW91dCBkdXJpbmcgJ3J1bm5pbmcnIHBoYXNlXG4gKiAtIFJpdmVyIGRlbHRhIGxheW91dCBkdXJpbmcgJ2ZpbmFsZScgcGhhc2UgKHRpZ2h0IHJvb3QsIG9yZ2FuaWNhbGx5IHNwcmVhZGluZyB0cmlidXRhcmllcylcbiAqIC0gU21vb3RoIENhdG11bGwtUm9tIGN1cnZlZCBwYXRoc1xuICogLSBBbmltYXRlZCBpbmRpdmlkdWFsIGF1ZGllbmNlIHBhdGhzIGR1cmluZyBmaW5hbGVcbiAqL1xuXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdHlwZSB7IER1YWxQYXRocywgT3B0aW9uSWQsIFJvd1BoYXNlLCBTaG93Q29uZmlnLCBTaG93UGhhc2UsIEZpbmFsZVRpbWVsaW5lIH0gZnJvbSAnQC9jb25kdWN0b3IvdHlwZXMnO1xuXG4vLyDilIDilIDilIAgVHlwZXMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbmV4cG9ydCBpbnRlcmZhY2UgU29uZ1RyZWVQcm9wcyB7XG4gIHJvd3M6IEFycmF5PHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIG9wdGlvbnM6IEFycmF5PHtcbiAgICAgIGlkOiBPcHRpb25JZDtcbiAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICBhdWRpb1JlZjogc3RyaW5nO1xuICAgICAgaGFybW9uaWNHcm91cD86IHN0cmluZztcbiAgICB9PjtcbiAgICBwaGFzZTogUm93UGhhc2U7XG4gICAgY29tbWl0dGVkT3B0aW9uOiBPcHRpb25JZCB8IG51bGw7XG4gICAgY3VycmVudEF1ZGl0aW9uSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgYXR0ZW1wdHM6IG51bWJlcjtcbiAgfT47XG4gIHBhdGhzOiBEdWFsUGF0aHM7XG4gIGN1cnJlbnRSb3dJbmRleDogbnVtYmVyO1xuICBjb25maWc/OiBTaG93Q29uZmlnO1xuICAvLyBOZXcgcHJvcHMgZm9yIGZpbmFsZSBzdXBwb3J0XG4gIHNob3dQaGFzZTogU2hvd1BoYXNlO1xuICBmaW5hbGVQaGFzZT86ICdwb3B1bGFyX3NvbmcnIHwgJ2luZGl2aWR1YWxfdGltZWxpbmVzJyB8IG51bGw7XG4gIGN1cnJlbnRGaW5hbGVUaW1lbGluZT86IEZpbmFsZVRpbWVsaW5lIHwgbnVsbDtcbiAgZmFjdGlvbkNvbG9ycz86IHN0cmluZ1tdO1xuICBhdWRpZW5jZVRpbWVsaW5lcz86IEZpbmFsZVRpbWVsaW5lW107XG59XG5cbmludGVyZmFjZSBQb2ludCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgTGF5b3V0Q29uZmlnIHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHJvd3M6IG51bWJlcjtcbiAgb3B0aW9uczogbnVtYmVyO1xufVxuXG50eXBlIExheW91dE1vZGUgPSAnZ3JpZCcgfCAndHJlZScgfCAndHJhbnNpdGlvbmluZyc7XG5cbi8vIOKUgOKUgOKUgCBDb25zdGFudHMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXG5cbmNvbnN0IFNWR19XSURUSCA9IDgwMDtcbmNvbnN0IFNWR19IRUlHSFQgPSA3MDA7XG5jb25zdCBPUFRJT05TX1BFUl9ST1cgPSA0O1xuXG5jb25zdCBGQUNUSU9OX0NPTE9SUyA9IFsnI2UwNWM1YycsICcjNWNiOGUwJywgJyM1Y2UwOGEnLCAnI2UwYzU1YyddO1xuY29uc3QgRE9UX1JBRElVUyA9IDg7XG5jb25zdCBXSU5ORVJfUkFESVVTID0gMTE7XG5cbi8vIEdyaWQgbGF5b3V0IHNwYWNpbmdcbmNvbnN0IEdSSURfQ09MX1NQQUNJTkcgPSA3MDtcbmNvbnN0IEdSSURfUk9XX1NQQUNJTkcgPSA1NjtcblxuLy8gVHJhbnNpdGlvbiBkdXJhdGlvblxuY29uc3QgVFJBTlNJVElPTl9EVVJBVElPTl9NUyA9IDE1MDA7XG5cbi8vIOKUgOKUgOKUgCBMYXlvdXQgRnVuY3Rpb25zIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG4vKipcbiAqIEdyaWQgcG9zaXRpb24gLSBsaW5lYXIgbGF5b3V0IHVzZWQgZHVyaW5nICdydW5uaW5nJyBwaGFzZVxuICogQm90dG9tLXRvLXRvcDogcm93IDAgYXQgYm90dG9tLCBoaWdoZXIgcm93cyBhdCB0b3BcbiAqL1xuZnVuY3Rpb24gZ3JpZFBvc2l0aW9uKHJvdzogbnVtYmVyLCBvcHRpb246IG51bWJlciwgY29uZmlnOiBMYXlvdXRDb25maWcpOiBQb2ludCB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY29uZmlnO1xuICBjb25zdCB4ID0gd2lkdGggLyAyIC0gR1JJRF9DT0xfU1BBQ0lORyAqIDEuNSArIG9wdGlvbiAqIEdSSURfQ09MX1NQQUNJTkc7XG4gIGNvbnN0IHkgPSBoZWlnaHQgLSA3MCAtIHJvdyAqIEdSSURfUk9XX1NQQUNJTkc7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cblxuLyoqXG4gKiBEZWx0YSBwb3NpdGlvbiAtIHJpdmVyIGRlbHRhIC8gdHJpYnV0YXJ5IGxheW91dCB1c2VkIGR1cmluZyAnZmluYWxlJyBwaGFzZVxuICogU2luZ2xlIHNvdXJjZSBhdCBib3R0b20sIHBhdGhzIGJyYW5jaCBvdXR3YXJkIHdpdGggb3JnYW5pYyBzcHJlYWQuXG4gKiBKaXR0ZXIgaW5jcmVhc2VzIHdpdGggcm93IGRlcHRoIGZvciBuYXR1cmFsIGFzeW1tZXRyeS5cbiAqL1xuZnVuY3Rpb24gZGVsdGFQb3NpdGlvbihcbiAgcm93OiBudW1iZXIsXG4gIG9wdGlvbjogbnVtYmVyLFxuICBjb25maWc6IExheW91dENvbmZpZyxcbiAgaml0dGVyOiBSZWNvcmQ8c3RyaW5nLCB7IGR4OiBudW1iZXI7IGR5OiBudW1iZXIgfT5cbik6IFBvaW50IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb25maWc7XG5cbiAgLy8gQm90dG9tLXRvLXRvcCBZIHBvc2l0aW9uaW5nIHdpdGggaW5jcmVhc2luZyBzcGFjaW5nIHRvd2FyZCB0aGUgdG9wXG4gIGNvbnN0IHkwID0gaGVpZ2h0IC0gNjA7XG4gIGNvbnN0IHlUb3AgPSA2MDtcbiAgY29uc3QgdG90YWxIID0geTAgLSB5VG9wO1xuXG4gIC8vIFVzZSBhIHNsaWdodCBwb3dlciBjdXJ2ZSBzbyB1cHBlciByb3dzIGdldCBtb3JlIHJvb20gdG8gc3ByZWFkXG4gIGNvbnN0IHQgPSByb3cgLyAoY29uZmlnLnJvd3MgLSAxKTsgLy8gMCBhdCBib3R0b20sIDEgYXQgdG9wXG4gIGxldCB5ID0geTAgLSB0ICogdG90YWxIO1xuXG4gIC8vIFNwcmVhZCBpbmNyZWFzZXMgYXMgYSBwb3dlciBjdXJ2ZSDigJQgdGlnaHQgYXQgdGhlIHJvb3QsIHdpZGUgYXQgdGhlIHRpcHNcbiAgY29uc3Qgc3ByZWFkID0gMjAgKyBNYXRoLnBvdyhyb3csIDEuOCkgKiAxNDtcblxuICAvLyA0IG9wdGlvbnMgZXZlbmx5IGRpc3RyaWJ1dGVkIGFjcm9zcyB0aGUgc3ByZWFkXG4gIGNvbnN0IG9mZnNldHMgPSBbLTEuNSwgLTAuNSwgMC41LCAxLjVdO1xuICBsZXQgeCA9IHdpZHRoIC8gMiArIG9mZnNldHNbb3B0aW9uXSAqIHNwcmVhZDtcblxuICAvLyBBcHBseSBzdGFibGUgaml0dGVyIOKAlCBpbmNyZWFzZXMgd2l0aCByb3cgZm9yIG9yZ2FuaWMgZmVlbFxuICBjb25zdCBrZXkgPSBgJHtyb3d9LSR7b3B0aW9ufWA7XG4gIGlmIChqaXR0ZXJba2V5XSkge1xuICAgIHggKz0gaml0dGVyW2tleV0uZHg7XG4gICAgeSArPSBqaXR0ZXJba2V5XS5keTtcbiAgfVxuXG4gIHJldHVybiB7IHgsIHkgfTtcbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIGdyaWQgYW5kIHRyZWUgcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlZFBvc2l0aW9uKFxuICByb3c6IG51bWJlcixcbiAgb3B0aW9uOiBudW1iZXIsXG4gIGNvbmZpZzogTGF5b3V0Q29uZmlnLFxuICBwcm9ncmVzczogbnVtYmVyLFxuICBqaXR0ZXI6IFJlY29yZDxzdHJpbmcsIHsgZHg6IG51bWJlcjsgZHk6IG51bWJlciB9PlxuKTogUG9pbnQge1xuICBjb25zdCBncmlkUG9zID0gZ3JpZFBvc2l0aW9uKHJvdywgb3B0aW9uLCBjb25maWcpO1xuICBjb25zdCBkZWx0YVBvcyA9IGRlbHRhUG9zaXRpb24ocm93LCBvcHRpb24sIGNvbmZpZywgaml0dGVyKTtcblxuICByZXR1cm4ge1xuICAgIHg6IGdyaWRQb3MueCArIChkZWx0YVBvcy54IC0gZ3JpZFBvcy54KSAqIHByb2dyZXNzLFxuICAgIHk6IGdyaWRQb3MueSArIChkZWx0YVBvcy55IC0gZ3JpZFBvcy55KSAqIHByb2dyZXNzLFxuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHN0YWJsZSBqaXR0ZXIgZm9yIGRlbHRhIGxheW91dC5cbiAqIEppdHRlciBtYWduaXR1ZGUgaW5jcmVhc2VzIHdpdGggcm93IGluZGV4IOKAlCB0aWdodCBhdCByb290LCBsb29zZSBhdCB0aXBzLlxuICogUm93IDAgZ2V0cyBubyBqaXR0ZXIgKGNvbW1vbiBzb3VyY2UpLCBoaWdoZXIgcm93cyBzcHJlYWQgb3JnYW5pY2FsbHkuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRGVsdGFKaXR0ZXIoc2VlZDogbnVtYmVyLCBudW1Sb3dzOiBudW1iZXIpOiBSZWNvcmQ8c3RyaW5nLCB7IGR4OiBudW1iZXI7IGR5OiBudW1iZXIgfT4ge1xuICBsZXQgcyA9IHNlZWQ7XG4gIGNvbnN0IHJhbmQgPSAoKSA9PiB7XG4gICAgcyA9IChzICogMTY4MDcgKyAwKSAlIDIxNDc0ODM2NDc7XG4gICAgcmV0dXJuIChzIC0gMSkgLyAyMTQ3NDgzNjQ2O1xuICB9O1xuXG4gIGNvbnN0IGppdHRlcjogUmVjb3JkPHN0cmluZywgeyBkeDogbnVtYmVyOyBkeTogbnVtYmVyIH0+ID0ge307XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG51bVJvd3M7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgb3B0ID0gMDsgb3B0IDwgT1BUSU9OU19QRVJfUk9XOyBvcHQrKykge1xuICAgICAgLy8gU2NhbGUgaml0dGVyOiBub25lIGF0IHJvdyAwLCBpbmNyZWFzaW5nIHRvd2FyZCB0b3Agcm93c1xuICAgICAgY29uc3QgbWFnbml0dWRlID0gcm93IDw9IDEgPyAwIDogTWF0aC5wb3cocm93IC0gMSwgMS4yKSAqIDQ7XG4gICAgICBqaXR0ZXJbYCR7cm93fS0ke29wdH1gXSA9IHtcbiAgICAgICAgZHg6IChyYW5kKCkgLSAwLjUpICogbWFnbml0dWRlLFxuICAgICAgICBkeTogKHJhbmQoKSAtIDAuNSkgKiBtYWduaXR1ZGUgKiAwLjYsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gaml0dGVyO1xufVxuXG4vLyDilIDilIDilIAgQ3VydmUgR2VuZXJhdGlvbiDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKHAxOiBQb2ludCwgcDI6IFBvaW50KTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguc3FydCgocDIueCAtIHAxLngpICoqIDIgKyAocDIueSAtIHAxLnkpICoqIDIpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgQ2F0bXVsbC1Sb20gc3BsaW5lIHBhdGggc3RyaW5nXG4gKiBBbHBoYSAwLjUgPSBjZW50cmlwZXRhbCAoYXZvaWRzIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMpXG4gKi9cbmZ1bmN0aW9uIGNhdG11bGxSb21QYXRoKHBvaW50czogUG9pbnRbXSwgYWxwaGE6IG51bWJlciA9IDAuNSk6IHN0cmluZyB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSByZXR1cm4gYE0gJHtwb2ludHNbMF0ueH0sJHtwb2ludHNbMF0ueX1gO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBgTSAke3BvaW50c1swXS54fSwke3BvaW50c1swXS55fSBMICR7cG9pbnRzWzFdLnh9LCR7cG9pbnRzWzFdLnl9YDtcbiAgfVxuXG4gIC8vIER1cGxpY2F0ZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgZm9yIGVuZCB0YW5nZW50c1xuICBjb25zdCBleHRlbmRlZCA9IFtwb2ludHNbMF0sIC4uLnBvaW50cywgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXV07XG5cbiAgbGV0IHBhdGggPSBgTSAke3BvaW50c1swXS54fSwke3BvaW50c1swXS55fWA7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmRlZC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICBjb25zdCBwMCA9IGV4dGVuZGVkW2kgLSAxXTtcbiAgICBjb25zdCBwMSA9IGV4dGVuZGVkW2ldO1xuICAgIGNvbnN0IHAyID0gZXh0ZW5kZWRbaSArIDFdO1xuICAgIGNvbnN0IHAzID0gZXh0ZW5kZWRbaSArIDJdO1xuXG4gICAgY29uc3QgZDEgPSBkaXN0YW5jZShwMCwgcDEpO1xuICAgIGNvbnN0IGQyID0gZGlzdGFuY2UocDEsIHAyKTtcbiAgICBjb25zdCBkMyA9IGRpc3RhbmNlKHAyLCBwMyk7XG5cbiAgICAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgaWYgKGQxIDwgMC4wMDEgfHwgZDIgPCAwLjAwMSB8fCBkMyA8IDAuMDAxKSB7XG4gICAgICBwYXRoICs9IGAgTCAke3AyLnh9LCR7cDIueX1gO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZDFhID0gTWF0aC5wb3coZDEsIGFscGhhKTtcbiAgICBjb25zdCBkMmEgPSBNYXRoLnBvdyhkMiwgYWxwaGEpO1xuICAgIGNvbnN0IGQzYSA9IE1hdGgucG93KGQzLCBhbHBoYSk7XG5cbiAgICBjb25zdCBkMWEyID0gTWF0aC5wb3coZDEsIDIgKiBhbHBoYSk7XG4gICAgY29uc3QgZDJhMiA9IE1hdGgucG93KGQyLCAyICogYWxwaGEpO1xuICAgIGNvbnN0IGQzYTIgPSBNYXRoLnBvdyhkMywgMiAqIGFscGhhKTtcblxuICAgIC8vIENvbnRyb2wgcG9pbnQgMVxuICAgIGNvbnN0IGRlbm9tMSA9IDMgKiBkMWEgKiAoZDFhICsgZDJhKTtcbiAgICBjb25zdCBjcDF4ID0gZGVub20xICE9PSAwXG4gICAgICA/IChkMWEyICogcDIueCAtIGQyYTIgKiBwMC54ICsgKDIgKiBkMWEyICsgMyAqIGQxYSAqIGQyYSArIGQyYTIpICogcDEueCkgLyBkZW5vbTFcbiAgICAgIDogKHAxLnggKyBwMi54KSAvIDI7XG4gICAgY29uc3QgY3AxeSA9IGRlbm9tMSAhPT0gMFxuICAgICAgPyAoZDFhMiAqIHAyLnkgLSBkMmEyICogcDAueSArICgyICogZDFhMiArIDMgKiBkMWEgKiBkMmEgKyBkMmEyKSAqIHAxLnkpIC8gZGVub20xXG4gICAgICA6IChwMS55ICsgcDIueSkgLyAyO1xuXG4gICAgLy8gQ29udHJvbCBwb2ludCAyXG4gICAgY29uc3QgZGVub20yID0gMyAqIGQzYSAqIChkM2EgKyBkMmEpO1xuICAgIGNvbnN0IGNwMnggPSBkZW5vbTIgIT09IDBcbiAgICAgID8gKGQzYTIgKiBwMS54IC0gZDJhMiAqIHAzLnggKyAoMiAqIGQzYTIgKyAzICogZDNhICogZDJhICsgZDJhMikgKiBwMi54KSAvIGRlbm9tMlxuICAgICAgOiAocDEueCArIHAyLngpIC8gMjtcbiAgICBjb25zdCBjcDJ5ID0gZGVub20yICE9PSAwXG4gICAgICA/IChkM2EyICogcDEueSAtIGQyYTIgKiBwMy55ICsgKDIgKiBkM2EyICsgMyAqIGQzYSAqIGQyYSArIGQyYTIpICogcDIueSkgLyBkZW5vbTJcbiAgICAgIDogKHAxLnkgKyBwMi55KSAvIDI7XG5cbiAgICBwYXRoICs9IGAgQyAke2NwMXh9LCR7Y3AxeX0gJHtjcDJ4fSwke2NwMnl9ICR7cDIueH0sJHtwMi55fWA7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuLy8g4pSA4pSA4pSAIFV0aWxpdHkgRnVuY3Rpb25zIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxuXG4vKipcbiAqIFBhcnNlIG9wdGlvbiBpbmRleCBmcm9tIG9wdGlvbklkIChlLmcuLCBcInIwLW9wdDJcIiDihpIgMilcbiAqL1xuZnVuY3Rpb24gcGFyc2VPcHRpb25JbmRleChvcHRpb25JZDogT3B0aW9uSWQpOiBudW1iZXIge1xuICBjb25zdCBtYXRjaCA9IG9wdGlvbklkLm1hdGNoKC9vcHQoXFxkKykkLyk7XG4gIHJldHVybiBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAwO1xufVxuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbiBmb3Igc21vb3RoIGFuaW1hdGlvblxuICovXG5mdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyh0OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAxIC0gTWF0aC5wb3coLTIgKiB0ICsgMiwgMykgLyAyO1xufVxuXG4vLyDilIDilIDilIAgQW5pbWF0ZWRQYXRoIENvbXBvbmVudCDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuaW50ZXJmYWNlIEFuaW1hdGVkUGF0aFByb3BzIHtcbiAgcGF0aDogc3RyaW5nO1xuICBjb2xvcjogc3RyaW5nO1xuICBzdHJva2VXaWR0aDogbnVtYmVyO1xuICBkYXNoQXJyYXk/OiBzdHJpbmc7XG4gIG9wYWNpdHk/OiBudW1iZXI7XG4gIGRlbGF5PzogbnVtYmVyO1xuICBkdXJhdGlvbj86IG51bWJlcjtcbn1cblxuY29uc3QgQW5pbWF0ZWRQYXRoID0gbWVtbyhmdW5jdGlvbiBBbmltYXRlZFBhdGgoe1xuICBwYXRoLFxuICBjb2xvcixcbiAgc3Ryb2tlV2lkdGgsXG4gIGRhc2hBcnJheSxcbiAgb3BhY2l0eSA9IDEsXG4gIGRlbGF5ID0gMCxcbiAgZHVyYXRpb24gPSAxMjAwLFxufTogQW5pbWF0ZWRQYXRoUHJvcHMpIHtcbiAgY29uc3QgcGF0aFJlZiA9IHVzZVJlZjxTVkdQYXRoRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtwYXRoTGVuZ3RoLCBzZXRQYXRoTGVuZ3RoXSA9IHVzZVN0YXRlKDApO1xuICAvLyBUcmFjayBob3cgbXVjaCBvZiB0aGUgcGF0aCB3ZSd2ZSBhbHJlYWR5IGFuaW1hdGVkIChyZXZlYWxlZClcbiAgY29uc3QgYW5pbWF0ZWRMZW5ndGhSZWYgPSB1c2VSZWYoMCk7XG4gIC8vIEFuaW1hdGlvbiBzdGF0ZTogJ2lkbGUnIHwgJ3ByZXBhcmluZycgfCAnYW5pbWF0aW5nJ1xuICBjb25zdCBbYW5pbVN0YXRlLCBzZXRBbmltU3RhdGVdID0gdXNlU3RhdGU8J2lkbGUnIHwgJ3ByZXBhcmluZycgfCAnYW5pbWF0aW5nJz4oJ2lkbGUnKTtcbiAgLy8gU3RvcmUgdGhlIG9mZnNldCB0byBhbmltYXRlIGZyb21cbiAgY29uc3QgW3RhcmdldE9mZnNldCwgc2V0VGFyZ2V0T2Zmc2V0XSA9IHVzZVN0YXRlKDApO1xuXG4gIC8vIE1lYXN1cmUgcGF0aCBsZW5ndGggd2hlbiBwYXRoIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBhdGhSZWYuY3VycmVudCB8fCAhcGF0aCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gcGF0aFJlZi5jdXJyZW50LmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgc2V0UGF0aExlbmd0aCh0b3RhbExlbmd0aCk7XG4gIH0sIFtwYXRoXSk7XG5cbiAgLy8gRGV0ZWN0IG5ldyBzZWdtZW50cyBhbmQgdHJpZ2dlciBhbmltYXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocGF0aExlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgbmV3U2VnbWVudExlbmd0aCA9IHBhdGhMZW5ndGggLSBhbmltYXRlZExlbmd0aFJlZi5jdXJyZW50O1xuXG4gICAgaWYgKG5ld1NlZ21lbnRMZW5ndGggPiAwLjUpIHtcbiAgICAgIC8vIE5ldyBzZWdtZW50IHRvIGFuaW1hdGUgLSBzZXQgdXAgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICAgICAgc2V0VGFyZ2V0T2Zmc2V0KG5ld1NlZ21lbnRMZW5ndGgpO1xuICAgICAgc2V0QW5pbVN0YXRlKCdwcmVwYXJpbmcnKTtcbiAgICB9XG4gIH0sIFtwYXRoTGVuZ3RoXSk7XG5cbiAgLy8gSGFuZGxlIGFuaW1hdGlvbiBzdGF0ZSBtYWNoaW5lXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFuaW1TdGF0ZSA9PT0gJ3ByZXBhcmluZycpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBcImhpZGRlblwiIHN0YXRlIHRvIHJlbmRlciwgdGhlbiBzdGFydCBhbmltYXRpb25cbiAgICAgIGNvbnN0IHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldEFuaW1TdGF0ZSgnYW5pbWF0aW5nJyk7XG4gICAgICAgICAgICAvLyBNYXJrIHRoaXMgbGVuZ3RoIGFzIGFuaW1hdGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgYW5pbWF0ZWRMZW5ndGhSZWYuY3VycmVudCA9IHBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIHNldEFuaW1TdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH1cbiAgfSwgW2FuaW1TdGF0ZSwgcGF0aExlbmd0aCwgZGVsYXksIGR1cmF0aW9uXSk7XG5cbiAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAvLyBDYWxjdWxhdGUgZGFzaCBvZmZzZXQgYmFzZWQgb24gYW5pbWF0aW9uIHN0YXRlXG4gIGxldCBkYXNoT2Zmc2V0ID0gMDtcbiAgaWYgKGFuaW1TdGF0ZSA9PT0gJ3ByZXBhcmluZycpIHtcbiAgICBkYXNoT2Zmc2V0ID0gdGFyZ2V0T2Zmc2V0OyAvLyBIaWRkZW4gLSBuZXcgc2VnbWVudCBub3QgdmlzaWJsZVxuICB9IGVsc2UgaWYgKGFuaW1TdGF0ZSA9PT0gJ2FuaW1hdGluZycpIHtcbiAgICBkYXNoT2Zmc2V0ID0gMDsgLy8gUmV2ZWFsZWQgLSBhbmltYXRlIHRvIHRoaXNcbiAgfVxuICAvLyBXaGVuIGlkbGUsIG9mZnNldCBpcyAwIChmdWxseSB2aXNpYmxlKVxuXG4gIC8vIEZvciBzb2xpZCBsaW5lczogdXNlIHBhdGhMZW5ndGggYXMgc2luZ2xlIGRhc2ggZm9yIGFuaW1hdGlvblxuICAvLyBGb3IgZGFzaGVkIGxpbmVzOiB1c2UgdGhlIGN1c3RvbSBwYXR0ZXJuIChhbmltYXRpb24gd29uJ3Qgd29yayBhcyBzbW9vdGhseSlcbiAgY29uc3QgZWZmZWN0aXZlRGFzaEFycmF5ID0gZGFzaEFycmF5IHx8IGAke3BhdGhMZW5ndGh9YDtcblxuICByZXR1cm4gKFxuICAgIDxwYXRoXG4gICAgICByZWY9e3BhdGhSZWZ9XG4gICAgICBkPXtwYXRofVxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgc3Ryb2tlPXtjb2xvcn1cbiAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgIHN0cm9rZURhc2hhcnJheT17ZWZmZWN0aXZlRGFzaEFycmF5fVxuICAgICAgc3Ryb2tlRGFzaG9mZnNldD17ZGFzaE9mZnNldH1cbiAgICAgIG9wYWNpdHk9e29wYWNpdHl9XG4gICAgICBzdHlsZT17e1xuICAgICAgICB0cmFuc2l0aW9uOiBhbmltU3RhdGUgPT09ICdhbmltYXRpbmcnXG4gICAgICAgICAgPyBgc3Ryb2tlLWRhc2hvZmZzZXQgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dCwgb3BhY2l0eSAxcyBlYXNlYFxuICAgICAgICAgIDogJ25vbmUnLFxuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG5cbi8vIOKUgOKUgOKUgCBNYWluIENvbXBvbmVudCDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuZXhwb3J0IGNvbnN0IFNvbmdUcmVlID0gbWVtbyhmdW5jdGlvbiBTb25nVHJlZSh7XG4gIHJvd3MsXG4gIHBhdGhzLFxuICBjdXJyZW50Um93SW5kZXgsXG4gIHNob3dQaGFzZSxcbiAgZmluYWxlUGhhc2UsXG4gIGN1cnJlbnRGaW5hbGVUaW1lbGluZSxcbiAgZmFjdGlvbkNvbG9ycyA9IEZBQ1RJT05fQ09MT1JTLFxuICBhdWRpZW5jZVRpbWVsaW5lcyxcbn06IFNvbmdUcmVlUHJvcHMpIHtcbiAgLy8gRGVmZW5zaXZlIGNoZWNrOiBlbnN1cmUgcm93cyBleGlzdFxuICBpZiAoIXJvd3MgfHwgcm93cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6ICcjOTk5JywgZm9udFNpemU6ICcxLjVyZW0nLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxuICAgICAgICAgIExvYWRpbmcgc29uZyB0cmVlLi4uXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIExheW91dCBzdGF0ZSAtIGFsd2F5cyBzdGFydCBpbiBncmlkIG1vZGUsIGxldCB1c2VFZmZlY3QgaGFuZGxlIHRyYW5zaXRpb25cbiAgY29uc3QgW2xheW91dE1vZGUsIHNldExheW91dE1vZGVdID0gdXNlU3RhdGU8TGF5b3V0TW9kZT4oJ3RyZWUnKTtcbiAgY29uc3QgW2xheW91dFByb2dyZXNzLCBzZXRMYXlvdXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBHZW5lcmF0ZSBtb2NrIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgdGVzdGluZyAoMzAgdXNlcnMgd2l0aCByYW5kb20gcGF0aHMpXG4gIGNvbnN0IG1vY2tUaW1lbGluZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB0aW1lbGluZXM6IEZpbmFsZVRpbWVsaW5lW10gPSBbXTtcbiAgICBjb25zdCBudW1Sb3dzID0gcm93cy5sZW5ndGg7XG5cbiAgICAvLyBTZWVkZWQgcmFuZG9tIGZvciByZXByb2R1Y2liaWxpdHlcbiAgICBsZXQgc2VlZCA9IDQyO1xuICAgIGNvbnN0IHJhbmQgPSAoKSA9PiB7XG4gICAgICBzZWVkID0gKHNlZWQgKiAxNjgwNyArIDApICUgMjE0NzQ4MzY0NztcbiAgICAgIHJldHVybiAoc2VlZCAtIDEpIC8gMjE0NzQ4MzY0NjtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBudW1Sb3dzOyByKyspIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gTWF0aC5mbG9vcihyYW5kKCkgKiBPUFRJT05TX1BFUl9ST1cpO1xuICAgICAgICBwYXRoLnB1c2goYHIke3J9LW9wdCR7b3B0aW9uSWR4fWApO1xuICAgICAgfVxuICAgICAgdGltZWxpbmVzLnB1c2goe1xuICAgICAgICB1c2VySWQ6IGBtb2NrLXVzZXItJHtpfWAsXG4gICAgICAgIHBhdGg6IHBhdGggYXMgT3B0aW9uSWRbXSxcbiAgICAgICAgZmlnVHJlZVJlc3BvbnNlOiAnJyxcbiAgICAgICAgaGFybW9uaWNHcm91cDogJ0EnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lbGluZXM7XG4gIH0sIFtyb3dzLmxlbmd0aF0pO1xuXG4gIC8vIEFjY3VtdWxhdGVkIGF1ZGllbmNlIHRpbWVsaW5lcyBmb3IgZmluYWxlXG4gIGNvbnN0IFtyZXZlYWxlZFRpbWVsaW5lcywgc2V0UmV2ZWFsZWRUaW1lbGluZXNdID0gdXNlU3RhdGU8RmluYWxlVGltZWxpbmVbXT4oW10pO1xuXG4gIC8vIFVzZSBwcm92aWRlZCB0aW1lbGluZXMsIG9yIG1vY2sgdGltZWxpbmVzIGZvciB0ZXN0aW5nIHdoZW4gaW4gZmluYWxlXG4gIGNvbnN0IGVmZmVjdGl2ZVRpbWVsaW5lcyA9IGF1ZGllbmNlVGltZWxpbmVzID8/IChzaG93UGhhc2UgPT09ICdmaW5hbGUnID8gbW9ja1RpbWVsaW5lcyA6IFtdKTtcblxuICAvLyBHZW5lcmF0ZSBzdGFibGUgZGVsdGEgaml0dGVyXG4gIGNvbnN0IGRlbHRhSml0dGVyID0gdXNlTWVtbygoKSA9PiBnZW5lcmF0ZURlbHRhSml0dGVyKDEyMywgcm93cy5sZW5ndGgpLCBbcm93cy5sZW5ndGhdKTtcblxuICAvLyBMYXlvdXQgY29uZmlndXJhdGlvblxuICBjb25zdCBsYXlvdXRDb25maWc6IExheW91dENvbmZpZyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHdpZHRoOiBTVkdfV0lEVEgsXG4gICAgICBoZWlnaHQ6IFNWR19IRUlHSFQsXG4gICAgICByb3dzOiByb3dzLmxlbmd0aCxcbiAgICAgIG9wdGlvbnM6IE9QVElPTlNfUEVSX1JPVyxcbiAgICB9KSxcbiAgICBbcm93cy5sZW5ndGhdXG4gICk7XG5cbiAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiBlbnRlcmluZyBmaW5hbGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2hvd1BoYXNlID09PSAnZmluYWxlJyAmJiBsYXlvdXRNb2RlICE9PSAndHJlZScpIHtcbiAgICAgIHNldExheW91dE1vZGUoJ3RyYW5zaXRpb25pbmcnKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCBhbmltYXRlID0gKG5vdzogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIFRSQU5TSVRJT05fRFVSQVRJT05fTVMsIDEpO1xuICAgICAgICBjb25zdCBlYXNlZCA9IGVhc2VJbk91dEN1YmljKHByb2dyZXNzKTtcbiAgICAgICAgc2V0TGF5b3V0UHJvZ3Jlc3MoZWFzZWQpO1xuXG4gICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TGF5b3V0TW9kZSgndHJlZScpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfSBlbHNlIGlmIChzaG93UGhhc2UgPT09ICdydW5uaW5nJyAmJiBsYXlvdXRNb2RlID09PSAndHJlZScpIHtcbiAgICAgIC8vIFJlc2V0IHRvIGdyaWQgKGluc3RhbnQpIGlmIHJldHVybmluZyB0byBydW5uaW5nXG4gICAgICBzZXRMYXlvdXRNb2RlKCdncmlkJyk7XG4gICAgICBzZXRMYXlvdXRQcm9ncmVzcygwKTtcbiAgICAgIHNldFJldmVhbGVkVGltZWxpbmVzKFtdKTtcbiAgICB9XG4gIH0sIFtzaG93UGhhc2UsIGxheW91dE1vZGVdKTtcblxuICAvLyBBY2N1bXVsYXRlIHJldmVhbGVkIHRpbWVsaW5lcyBkdXJpbmcgZmluYWxlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY3VycmVudEZpbmFsZVRpbWVsaW5lICYmXG4gICAgICAhcmV2ZWFsZWRUaW1lbGluZXMuZmluZCgodCkgPT4gdC51c2VySWQgPT09IGN1cnJlbnRGaW5hbGVUaW1lbGluZS51c2VySWQpXG4gICAgKSB7XG4gICAgICBzZXRSZXZlYWxlZFRpbWVsaW5lcygocHJldikgPT4gWy4uLnByZXYsIGN1cnJlbnRGaW5hbGVUaW1lbGluZV0pO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRGaW5hbGVUaW1lbGluZSwgcmV2ZWFsZWRUaW1lbGluZXNdKTtcblxuICAvLyBQb3NpdGlvbiBmdW5jdGlvbiBiYXNlZCBvbiBsYXlvdXQgbW9kZVxuICBjb25zdCBnZXRQb3NpdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3c6IG51bWJlciwgb3B0aW9uOiBudW1iZXIpOiBQb2ludCA9PiB7XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ2dyaWQnIHx8IGxheW91dFByb2dyZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBncmlkUG9zaXRpb24ocm93LCBvcHRpb24sIGxheW91dENvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0TW9kZSA9PT0gJ3RyZWUnIHx8IGxheW91dFByb2dyZXNzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBkZWx0YVBvc2l0aW9uKHJvdywgb3B0aW9uLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcnBvbGF0ZWRQb3NpdGlvbihyb3csIG9wdGlvbiwgbGF5b3V0Q29uZmlnLCBsYXlvdXRQcm9ncmVzcywgZGVsdGFKaXR0ZXIpO1xuICAgIH0sXG4gICAgW2xheW91dE1vZGUsIGxheW91dFByb2dyZXNzLCBsYXlvdXRDb25maWcsIGRlbHRhSml0dGVyXVxuICApO1xuXG4gIC8vIEJ1aWxkIGZ1bGwgcGF0aCBzdHJpbmdzIGZvciBzbW9vdGggQ2F0bXVsbC1Sb20gY3VydmVzXG4gIGNvbnN0IGZhY3Rpb25QYXRoU3RyaW5nID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBhdGhzLmZhY3Rpb25QYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIGNvbnN0IHBvaW50cyA9IHBhdGhzLmZhY3Rpb25QYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uSWR4ID0gcGFyc2VPcHRpb25JbmRleChvcHRpb25JZCk7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24ocm93SWR4LCBvcHRpb25JZHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYXRtdWxsUm9tUGF0aChwb2ludHMpO1xuICB9LCBbcGF0aHMuZmFjdGlvblBhdGgsIGdldFBvc2l0aW9uXSk7XG5cbiAgY29uc3QgcG9wdWxhclBhdGhTdHJpbmcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGF0aHMucG9wdWxhclBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgcG9pbnRzID0gcGF0aHMucG9wdWxhclBhdGgubWFwKChvcHRpb25JZCwgcm93SWR4KSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihyb3dJZHgsIG9wdGlvbklkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhdG11bGxSb21QYXRoKHBvaW50cyk7XG4gIH0sIFtwYXRocy5wb3B1bGFyUGF0aCwgZ2V0UG9zaXRpb25dKTtcblxuICAvLyBCdWlsZCBhdWRpZW5jZSB0aW1lbGluZSBwYXRoIHN0cmluZ3NcbiAgY29uc3QgYXVkaWVuY2VQYXRoU3RyaW5ncyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBlZmZlY3RpdmVUaW1lbGluZXMubWFwKCh0aW1lbGluZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludHMgPSB0aW1lbGluZS5wYXRoLm1hcCgob3B0aW9uSWQsIHJvd0lkeCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25JZHggPSBwYXJzZU9wdGlvbkluZGV4KG9wdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHJvd0lkeCwgb3B0aW9uSWR4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkOiB0aW1lbGluZS51c2VySWQsXG4gICAgICAgIHBhdGg6IGNhdG11bGxSb21QYXRoKHBvaW50cyksXG4gICAgICAgIC8vIERldGVybWluZSBmYWN0aW9uIGZyb20gdXNlcklkIC0gZm9yIG5vdyB1c2UgbW9kdWxvIGFzIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIHVzZXIgZGF0YVxuICAgICAgICBmYWN0aW9uSW5kZXg6IGlkeCAlIDQsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbZWZmZWN0aXZlVGltZWxpbmVzLCBnZXRQb3NpdGlvbl0pO1xuXG4gIGNvbnN0IGlzVHJlZU1vZGUgPSBsYXlvdXRNb2RlID09PSAndHJlZScgfHwgbGF5b3V0UHJvZ3Jlc3MgPiAwO1xuICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBsYXlvdXRNb2RlID09PSAndHJhbnNpdGlvbmluZyc7XG4gIGNvbnN0IGhhc0F1ZGllbmNlUGF0aHMgPSBlZmZlY3RpdmVUaW1lbGluZXMubGVuZ3RoID4gMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgPHN2Z1xuICAgICAgICBzdHlsZT17c3R5bGVzLnN2Z31cbiAgICAgICAgdmlld0JveD17YDAgMCAke1NWR19XSURUSH0gJHtTVkdfSEVJR0hUfWB9XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCJcbiAgICAgID5cbiAgICAgICAgey8qIEF1ZGllbmNlIHRpbWVsaW5lIHBhdGhzIChmaW5hbGUgLSBpbmRpdmlkdWFsX3RpbWVsaW5lcyBwaGFzZSkgKi99XG4gICAgICAgIHtmaW5hbGVQaGFzZSA9PT0gJ2luZGl2aWR1YWxfdGltZWxpbmVzJyAmJlxuICAgICAgICAgIGF1ZGllbmNlUGF0aFN0cmluZ3MubWFwKChhcCwgaWR4KSA9PiAoXG4gICAgICAgICAgICA8QW5pbWF0ZWRQYXRoXG4gICAgICAgICAgICAgIGtleT17YXAudXNlcklkfVxuICAgICAgICAgICAgICBwYXRoPXthcC5wYXRofVxuICAgICAgICAgICAgICBjb2xvcj17ZmFjdGlvbkNvbG9yc1thcC5mYWN0aW9uSW5kZXhdIHx8IEZBQ1RJT05fQ09MT1JTWzBdfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICBkZWxheT17aWR4ICogMTAwfVxuICAgICAgICAgICAgICBkdXJhdGlvbj17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG5cbiAgICAgICAgey8qIFBvcHVsYXIgcGF0aCAoZ2hvc3QvZGFzaGVkKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e3BvcHVsYXJQYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiIzY2NlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezN9XG4gICAgICAgICAgZGFzaEFycmF5PVwiOCA0XCJcbiAgICAgICAgICBvcGFjaXR5PXtoYXNBdWRpZW5jZVBhdGhzID8gMC4yIDogMC41fVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5wb3B1bGFyUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIEZhY3Rpb24gcGF0aCAoc29saWQvd2lubmVyKSAqL31cbiAgICAgICAgPEFuaW1hdGVkUGF0aFxuICAgICAgICAgIHBhdGg9e2ZhY3Rpb25QYXRoU3RyaW5nfVxuICAgICAgICAgIGNvbG9yPVwiI2ZmZlwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezR9XG4gICAgICAgICAgb3BhY2l0eT17aGFzQXVkaWVuY2VQYXRocyA/IDAuMTUgOiAxfVxuICAgICAgICAgIGRlbGF5PXswfVxuICAgICAgICAgIGR1cmF0aW9uPXtwYXRocy5mYWN0aW9uUGF0aC5sZW5ndGggKiAzMDB9XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qIE9wdGlvbiBub2RlcyAqL31cbiAgICAgICAge3Jvd3MubWFwKChyb3cpID0+XG4gICAgICAgICAgcm93Lm9wdGlvbnMubWFwKChvcHRpb24sIG9wdElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCBvcHRJZHgpO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IHJvdy5waGFzZSAhPT0gJ3BlbmRpbmcnIHx8IHJvdy5pbmRleCA8PSBjdXJyZW50Um93SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBpc0NvbW1pdHRlZCA9IHJvdy5jb21taXR0ZWRPcHRpb24gPT09IG9wdGlvbi5pZDtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5GYWN0aW9uUGF0aCA9IHBhdGhzLmZhY3Rpb25QYXRoLmluY2x1ZGVzKG9wdGlvbi5pZCk7XG4gICAgICAgICAgICBjb25zdCBpc1dpbm5lciA9IHZpc2libGUgJiYgKGlzQ29tbWl0dGVkIHx8IGlzSW5GYWN0aW9uUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSByb3cuaW5kZXggPT09IGN1cnJlbnRSb3dJbmRleCAmJiByb3cucGhhc2UgIT09ICdwZW5kaW5nJztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGcga2V5PXtvcHRpb24uaWR9PlxuICAgICAgICAgICAgICAgIHsvKiBXaW5uZXIgZ2xvdyByaW5nICovfVxuICAgICAgICAgICAgICAgIHtpc1dpbm5lciAmJiAoXG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICAgIGN4PXtwb3MueH1cbiAgICAgICAgICAgICAgICAgICAgY3k9e3Bvcy55fVxuICAgICAgICAgICAgICAgICAgICByPXtXSU5ORVJfUkFESVVTICsgNn1cbiAgICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCIjZmZmXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9ezAuMTJ9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ2N4IDEuNXMgZWFzZS1pbi1vdXQsIGN5IDEuNXMgZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHsvKiBDdXJyZW50IHJvdyBnbG93ICovfVxuICAgICAgICAgICAgICAgIHtpc0N1cnJlbnQgJiYgIWlzV2lubmVyICYmIChcbiAgICAgICAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgY3g9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICAgIHI9e0RPVF9SQURJVVMgKyA4fVxuICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM0YWRlODBcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17MC40fVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB7LyogTWFpbiBub2RlIGNpcmNsZSAqL31cbiAgICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAgICBjeD17cG9zLnh9XG4gICAgICAgICAgICAgICAgICBjeT17cG9zLnl9XG4gICAgICAgICAgICAgICAgICByPXtpc1dpbm5lciA/IFdJTk5FUl9SQURJVVMgOiBET1RfUkFESVVTfVxuICAgICAgICAgICAgICAgICAgZmlsbD17IXZpc2libGUgPyAnIzFhMWEyMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjM2EzYTQ0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT17IXZpc2libGUgPyAnIzJhMmEzMicgOiBpc1dpbm5lciA/ICcjZmZmJyA6ICcjNGE0YTU0J31cbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXt2aXNpYmxlID8gMS41IDogMC41fVxuICAgICAgICAgICAgICAgICAgb3BhY2l0eT17dmlzaWJsZSA/IDEgOiAwLjM1fVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgPyAnciAwLjRzIGVhc2UsIGZpbGwgMC40cyBlYXNlLCBvcGFjaXR5IDAuNHMgZWFzZSdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdjeCAxLjVzIGVhc2UtaW4tb3V0LCBjeSAxLjVzIGVhc2UtaW4tb3V0LCByIDAuNHMgZWFzZSwgZmlsbCAwLjRzIGVhc2UsIG9wYWNpdHkgMC40cyBlYXNlJyxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7LyogT3B0aW9uIGxhYmVsICovfVxuICAgICAgICAgICAgICAgIHt2aXNpYmxlICYmIChcbiAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHg9e3Bvcy54fVxuICAgICAgICAgICAgICAgICAgICB5PXtwb3MueSArIDF9XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplPXs5fVxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0PXs3MDB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGw9e2lzV2lubmVyID8gJyMwYjBiMGYnIDogJyM2NjYnfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGlzVHJhbnNpdGlvbmluZyA/ICdub25lJyA6ICd4IDEuNXMgZWFzZS1pbi1vdXQsIHkgMS41cyBlYXNlLWluLW91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7U3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIG9wdElkeCl9XG4gICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApfVxuXG4gICAgICAgIHsvKiBSb3cgbGFiZWxzICovfVxuICAgICAgICB7cm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IHZpc2libGUgPSByb3cucGhhc2UgIT09ICdwZW5kaW5nJyB8fCByb3cuaW5kZXggPD0gY3VycmVudFJvd0luZGV4O1xuICAgICAgICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjb25zdCBsZWZ0UG9zID0gZ2V0UG9zaXRpb24ocm93LmluZGV4LCAwKTtcbiAgICAgICAgICBjb25zdCBsYWJlbFggPSBpc1RyZWVNb2RlXG4gICAgICAgICAgICA/IE1hdGgubWluKGxlZnRQb3MueCwgZ2V0UG9zaXRpb24ocm93LmluZGV4LCBPUFRJT05TX1BFUl9ST1cgLSAxKS54KSAtIDMwXG4gICAgICAgICAgICA6IGxlZnRQb3MueCAtIDQwO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgIGtleT17YGxhYmVsLSR7cm93LmluZGV4fWB9XG4gICAgICAgICAgICAgIHg9e2xhYmVsWH1cbiAgICAgICAgICAgICAgeT17bGVmdFBvcy55ICsgMX1cbiAgICAgICAgICAgICAgdGV4dEFuY2hvcj1cImVuZFwiXG4gICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9ezEwfVxuICAgICAgICAgICAgICBmaWxsPVwiIzQ0NFwiXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogaXNUcmFuc2l0aW9uaW5nID8gJ25vbmUnIDogJ3ggMS41cyBlYXNlLWluLW91dCwgeSAxLjVzIGVhc2UtaW4tb3V0JyxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3Jvdy5sYWJlbCB8fCBgUiR7cm93LmluZGV4ICsgMX1gfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICk7XG59KTtcblxuLy8g4pSA4pSA4pSAIFN0eWxlcyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIBcblxuY29uc3Qgc3R5bGVzID0ge1xuICBjb250YWluZXI6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzLFxuXG4gIHN2Zzoge1xuICAgIHdpZHRoOiAnOTAlJyxcbiAgICBoZWlnaHQ6ICc5MCUnLFxuICAgIG1heFdpZHRoOiBTVkdfV0lEVEgsXG4gICAgbWF4SGVpZ2h0OiBTVkdfSEVJR0hULFxuICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXMsXG59O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwibWVtbyIsIlNWR19XSURUSCIsIlNWR19IRUlHSFQiLCJPUFRJT05TX1BFUl9ST1ciLCJGQUNUSU9OX0NPTE9SUyIsIkRPVF9SQURJVVMiLCJXSU5ORVJfUkFESVVTIiwiR1JJRF9DT0xfU1BBQ0lORyIsIkdSSURfUk9XX1NQQUNJTkciLCJUUkFOU0lUSU9OX0RVUkFUSU9OX01TIiwiZ3JpZFBvc2l0aW9uIiwicm93Iiwib3B0aW9uIiwiY29uZmlnIiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsImRlbHRhUG9zaXRpb24iLCJqaXR0ZXIiLCJ5MCIsInlUb3AiLCJ0b3RhbEgiLCJ0Iiwicm93cyIsInNwcmVhZCIsIk1hdGgiLCJwb3ciLCJvZmZzZXRzIiwia2V5IiwiZHgiLCJkeSIsImludGVycG9sYXRlZFBvc2l0aW9uIiwicHJvZ3Jlc3MiLCJncmlkUG9zIiwiZGVsdGFQb3MiLCJnZW5lcmF0ZURlbHRhSml0dGVyIiwic2VlZCIsIm51bVJvd3MiLCJzIiwicmFuZCIsIm9wdCIsIm1hZ25pdHVkZSIsImRpc3RhbmNlIiwicDEiLCJwMiIsInNxcnQiLCJjYXRtdWxsUm9tUGF0aCIsInBvaW50cyIsImFscGhhIiwibGVuZ3RoIiwiZXh0ZW5kZWQiLCJwYXRoIiwiaSIsInAwIiwicDMiLCJkMSIsImQyIiwiZDMiLCJkMWEiLCJkMmEiLCJkM2EiLCJkMWEyIiwiZDJhMiIsImQzYTIiLCJkZW5vbTEiLCJjcDF4IiwiY3AxeSIsImRlbm9tMiIsImNwMngiLCJjcDJ5IiwicGFyc2VPcHRpb25JbmRleCIsIm9wdGlvbklkIiwibWF0Y2giLCJwYXJzZUludCIsImVhc2VJbk91dEN1YmljIiwiQW5pbWF0ZWRQYXRoIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsImRhc2hBcnJheSIsIm9wYWNpdHkiLCJkZWxheSIsImR1cmF0aW9uIiwicGF0aFJlZiIsInBhdGhMZW5ndGgiLCJzZXRQYXRoTGVuZ3RoIiwiYW5pbWF0ZWRMZW5ndGhSZWYiLCJhbmltU3RhdGUiLCJzZXRBbmltU3RhdGUiLCJ0YXJnZXRPZmZzZXQiLCJzZXRUYXJnZXRPZmZzZXQiLCJjdXJyZW50IiwidG90YWxMZW5ndGgiLCJnZXRUb3RhbExlbmd0aCIsIm5ld1NlZ21lbnRMZW5ndGgiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRhc2hPZmZzZXQiLCJlZmZlY3RpdmVEYXNoQXJyYXkiLCJyZWYiLCJkIiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJTb25nVHJlZSIsInBhdGhzIiwiY3VycmVudFJvd0luZGV4Iiwic2hvd1BoYXNlIiwiZmluYWxlUGhhc2UiLCJjdXJyZW50RmluYWxlVGltZWxpbmUiLCJmYWN0aW9uQ29sb3JzIiwiYXVkaWVuY2VUaW1lbGluZXMiLCJkaXYiLCJzdHlsZXMiLCJjb250YWluZXIiLCJmb250U2l6ZSIsInRleHRBbGlnbiIsImxheW91dE1vZGUiLCJzZXRMYXlvdXRNb2RlIiwibGF5b3V0UHJvZ3Jlc3MiLCJzZXRMYXlvdXRQcm9ncmVzcyIsIm1vY2tUaW1lbGluZXMiLCJ0aW1lbGluZXMiLCJyIiwib3B0aW9uSWR4IiwiZmxvb3IiLCJwdXNoIiwidXNlcklkIiwiZmlnVHJlZVJlc3BvbnNlIiwiaGFybW9uaWNHcm91cCIsInJldmVhbGVkVGltZWxpbmVzIiwic2V0UmV2ZWFsZWRUaW1lbGluZXMiLCJlZmZlY3RpdmVUaW1lbGluZXMiLCJkZWx0YUppdHRlciIsImxheW91dENvbmZpZyIsIm9wdGlvbnMiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImFuaW1hdGUiLCJlbGFwc2VkIiwibWluIiwiZWFzZWQiLCJmaW5kIiwicHJldiIsImdldFBvc2l0aW9uIiwiZmFjdGlvblBhdGhTdHJpbmciLCJmYWN0aW9uUGF0aCIsIm1hcCIsInJvd0lkeCIsInBvcHVsYXJQYXRoU3RyaW5nIiwicG9wdWxhclBhdGgiLCJhdWRpZW5jZVBhdGhTdHJpbmdzIiwidGltZWxpbmUiLCJpZHgiLCJmYWN0aW9uSW5kZXgiLCJpc1RyZWVNb2RlIiwiaXNUcmFuc2l0aW9uaW5nIiwiaGFzQXVkaWVuY2VQYXRocyIsInN2ZyIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiYXAiLCJvcHRJZHgiLCJwb3MiLCJpbmRleCIsInZpc2libGUiLCJwaGFzZSIsImlzQ29tbWl0dGVkIiwiY29tbWl0dGVkT3B0aW9uIiwiaWQiLCJpc0luRmFjdGlvblBhdGgiLCJpbmNsdWRlcyIsImlzV2lubmVyIiwiaXNDdXJyZW50IiwiZyIsImNpcmNsZSIsImN4IiwiY3kiLCJ0ZXh0IiwidGV4dEFuY2hvciIsImRvbWluYW50QmFzZWxpbmUiLCJmb250V2VpZ2h0IiwicG9pbnRlckV2ZW50cyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImxlZnRQb3MiLCJsYWJlbFgiLCJsYWJlbCIsInBvc2l0aW9uIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIm92ZXJmbG93IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SongTree.tsx\n"));

/***/ })

});